<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>EMF v1.0 Users' Guide</title>
<link rel="stylesheet" href="http://www.eclipse.org/default_style.css" type="text/css" />
<link rel="stylesheet" href="http://www.eclipse.org/emf/docs/book.css" type="text/css" />
<style type="text/css">
<!--
.jet {  background-color: #FFFFCC; }
pre {  color: #4444CC; }
tt.code { color: #4444CC; }
-->
</style>
</head>
<body lang="EN-US" xml:lang="EN-US">

<a id="top" name="top">&nbsp;</a>
 <h1>EMF v1.0 Users' Guide</h1> 
<p>
 Last updated on May 27, 2004, at 02:24pm (formatting only).
</p>
<p>
 Please report any broken or missing links to <a
href="mailto:codeslave@ca.ibm.com?Subject=EMF Users Guide - Broken Link Report">
Nick Boldt</a>.
</p>
<p>&nbsp;</p>
<p>
 <a class="" href="#toc"><b class="">Table of
Contents</b></a> &nbsp;|&nbsp; <a class="" href="#tof"><b
class="">Table of Figures</b></a> &nbsp;|&nbsp; <a class=""
href="#tot"><b class="">Table of Tables</b></a> 
</p>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s" name="s"><h1>Overview</h1></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>

<p>
 The Eclipse Modeling Framework, EMF, is a Java framework and code
generation facility for building tools and other applications based
on a structured model. EMF provides a mechanism to easily create,
save, and restore instances of the classes in your model. This
makes it very easy to share data across different
applications.
</p>
<p>
 This document describes the basic steps for using EMF, including
how to define your model, how to generate and customize your
application source code, and how to manipulate and save instance
data.
<ul>
<li>See <a class="" href="#s1000">Concepts</a>. outlines
some of the key concepts essential to the understanding of
EMF.</li>
<li>See <a class="" href="#s1001">Tasks</a>. gives examples
for how to use EMF to accomplish some commonly encountered
tasks.</li>
<li>See <a class="" href="#s1002">Quick Reference</a>. is a
short reference guide to the APIs used by an EMF application.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1000" name="s1000"><h1>1 Concepts</h1></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>

<p>
 We first present some of the key concepts upon which EMF is based.
This section is intended to introduce these fundamental concepts at
a high level and to give an indication of how they relate to EMF.
The concepts that are covered here are:
<ul>
<li>See <a class="" href="#s1003">Modeling</a>.</li>
<li>See <a class="" href="#s1004">Code
Generation</a>.</li>
<li>See <a class="" href="#s1005">Serialization and
Loading</a>.</li>
<li>See <a class="" href="#s1006">XMI</a>.</li>
<li>See <a class="" href="#s1007">Observers and
Notifiers</a>.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1003" name="s1003"><h2>1.01 Modeling</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 A model is an abstract representation of the data used by an
application. A model may be expressed simply as an informal
description of the data or it may be described precisely using any
of a number of formal mechanisms, for example:
<ul>
<li>UML created using a visual modeling tool</li>
<li>XML that conforms to a schema that expresses all the necessary
elements of the model</li>
<li>Java interfaces that may have additional annotations to capture
special information about the model that is not expressible
directly in Java</li></ul>

One of the advantages of using a formal definition of a model is
that EMF can then be used to assist in the automatic generation and
maintenance of application code based on the model. This in turn
facilitates the creation of multiple applications that can
communicate easily because they share a common view of the
underlying data.
</p>
<p>
 A model is constructed from classes that describe objects in an
application's domain. Each class may have attributes, associations,
and operations associated with it. Usually, the classes in a model
are grouped into one or more packages.
</p>
<p>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s" name="s"><h2>1.02 The Ecore Model</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 EMF is itself based on a model called Ecore. The Ecore model is
the meta-model for all application models that are handled by EMF.
(A "meta-model" is a model that represents other models.)
</p>
<p>
 The root of the Ecore Model is <tt class="code">EObject</tt>. All EMF objects implement the <tt class="code">EObject</tt> interface.
</p>
<p>
 The classes of the Ecore model include <tt class="code">EPackage</tt>, <tt class="code">EFactory</tt>, <tt class="code">EClass</tt>, and <tt class="code">EStructuralFeature</tt>. (See <a class=""
href="#s1008">Appendix A - The Ecore Model gives a more complete
description of the Ecore Model</a>.)
</p>
<p>
 If your model consists of a package that contains two classes, the
EMF representation of that model will consist of a single instance
each of <tt class="code">EPackage</tt> and <tt class="code">EFactory</tt> plus two instances of <tt class="code">EClass</tt>, along with however many instances of
<tt class="code">EStructuralFeature</tt> are needed to
represent the attributes and associations that belong to your
classes. When your application creates instances of your classes,
each of those instances will implement the <tt class="code">EObject</tt> interface.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1004" name="s1004"><h2>1.03 Code Generation</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 Code generation is the process of converting your model into the
Java source code for your application. In many cases, after you
generate your Java classes you will want to add methods or modify
the generated methods. EMF enables you to do this in a such a way
that if you later make a change to your model and regenerate, the
code generation process will preserve your changes.
</p>
<p>
 EMF provides two separate code generation facilities:
<ul>
<li>See <a class="" href="#s1009">Basic Code
Generation</a>. creates Java interfaces and classes that represent
the elements of your model. The generated APIs enable you to create
instances of your classes and access the structural features of
each class.</li>
<li>See <a class="" href="#s1010">EMF.Edit Code
Generation</a>. creates a simple graphical editor that can be used
to create, update, view, load, and store the Java classes that are
generated by basic code generation.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1009" name="s1009"><h2>1.04 Basic Code Generation</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The result of EMF basic code generation is two or three Java
packages for each package in your model. One of these Java packages
consists entirely of Java interfaces that define the APIs to access
instances of the classes in your model. The other Java package
consists of Java classes that implement those interfaces. The third
package, which is optional, contains a generated adapter factory
and a generated switch class. These classes are useful when
implementing adapters.
</p>
<p>
 The interface package includes one interface for each class in
your model. These interfaces extend the <tt class="code">EObject</tt> interface from the Ecore model. Each
interface provides methods that enable you to access an instance of
a class and to get and set the values for each of the features of
that class.
</p>
<p>
 The interface package also contains two additional interfaces: one
that extends the <tt class="code">EPackage</tt> interface
and another that extends the <tt class="code">EFactory</tt>
interface. The <tt class="code">EPackage</tt> interface
provides methods for accessing the meta-data from your model (i.e.,
the <tt class="code">EClass</tt> and <tt class="code">EStructuralFeature</tt> objects that describe
your classes) and the factory interface provides methods for
creating instances of your data (i.e., the <tt class="code">EObject</tt> objects that implement your
classes.)
</p>
<p>
 The implementation package has Java classes that implement all the
interfaces described above.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1005" name="s1005"><h2>1.05 Serialization and Loading</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 Serialization is the process of writing your instance data into a
standardized, persistent form, e.g., a file on your file system or
a Web <tt class="code">Resource</tt>.
</p>
<p>
 Loading (sometimes referred to as "deserialization") is the
process of reading the persistent form of the data to recreate
instances of <tt class="code">EObject</tt> in memory. In
EMF, loading can be accomplished either through an explicit call to
a load API or it can happen automatically whenever a reference to
an <tt class="code">EObject</tt> that has not yet been
loaded is encountered.
</p>
<p>
 The APIs that are used in EMF to control the loading and saving of
objects are defined on the See <tt class="code">Resource</tt>. and See <a class=""
href="#s1011"><tt class="code">ResourceSet</tt></a>.
interfaces.
</p>
<p>
 The default implementation of <tt class="code">Resource</tt> is <tt class="code">XMIResourceImpl</tt>, which results in
serialization as XMI documents. The See <a class=""
href="#s1012"><tt class="code">XMIResource</tt></a>.
interface provides additional APIs that enable you to control some
of the behavior of the default serializer and loader. If you wish
to serialize in some format other than the default XMI format, you
can provide your own implementation of <tt class="code">Resource</tt>.<br />
<br />
 <tt class="code">Resource</tt> 
</p>
<p>
 A <tt class="code">Resource</tt> is a collection of <tt class="code">EObject</tt> objects that are serialized into a
single <tt class="code">Stream</tt>.
</p>
<p>
 The <tt class="code">Resource</tt> interface is defined in
the package <tt class="code">org.eclipse.emf.ecore.Resource</tt>. It provides
APIs that enable you to:
<ul>
<li>Load a <tt class="code">Resource</tt> from an <tt class="code">InputStream</tt>.</li>
<li>Save a <tt class="code">Resource</tt> to an <tt class="code">OutputStream</tt>.</li>
<li>Access any messages that were generated during the load or save
operation.</li>
<li>Optionally keep track of whether any objects in a <tt class="code">Resource</tt> have been modified. The default is
not to keep track of modifications. Modification tracking can add
significant runtime overhead.</li>
<li>Register the default factory for creating <tt class="code">Resource</tt> objects. If you choose to provide
your own implementation of the <tt class="code">Resource</tt> interface, for example, so you can
use a serialization format other than XMI, you will need to define
and register a factory for creating your implementation of <tt class="code">Resource</tt>.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1011" name="s1011"><h2>1.06 <tt class="code">ResourceSet</tt></h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 A <tt class="code">ResourceSet</tt> is a collection of
<tt class="code">Resource</tt> objects that may have
cross-references among them.
</p>
<p>
 The <tt class="code">ResourceSet</tt> interface defines
APIs that enable you to:
<ul>
<li>Create a new See <a class="" href="#s1013"><tt class="code">Resource</tt></a>.</li>
<li>Look up an individual object and, if necessary, load the <tt class="code">Resource</tt> in which it is contained.</li>
<li>Set and get the See <a class="" href="#s1014"><tt class="code">URIConverter</tt></a>. used to normalize URIs and
resolve relative URIs.</li>
<li>Set and get a <tt class="code">Resource.Factory.Registry</tt>. (This registry
enables you to provide alternative implementations of <tt class="code">Resource</tt> and to have the appropriate
implementation selected based on either the extension or the
protocol of a given URI.)</li>
<li>Get the list of registered <tt class="code">AdapterFactory</tt> instances.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1014" name="s1014"><h2>1.07 <tt class="code">URIConverter</tt></h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 Uniform <tt class="code">Resource</tt> Identifiers or URIs,
as specified in <a class="" target="new"
href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>,
are used to uniquely identify resources and objects within
resources. For example, when one object references another object
that is located in a different <tt class="code">Resource</tt>, a URI is used to identify the
referenced object.
</p>
<p>
 Often it is convenient to have a URI that is expressed as a
relative location. For example, if the URI refers to a file on a
file system, it may be convenient to describe that file relative to
some known location rather than as an absolute path. This would
enable your application to run in different environments.
Similarly, a URI may refer to a <tt class="code">Resource</tt> within your Eclipse workbench, or
to an object on the Web. Expressing the URI as a relative value
rather than an absolute location provides the flexibility that is
needed to be able to share resources.
</p>
<p>
 A <tt class="code">URIConverter</tt> is used to resolve a
relative URI into an absolute InputStream or OutputStream. The
<tt class="code">URIConverter</tt> also provides an API to
normalize relative URIs. Normalization is used to determine if two
different URIs in fact refer to the same underlying object.
</p>
<p>
 EMF provides a default implementation of a <tt class="code">URIConverter</tt> and also enables you to create
and register your own implementation.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1006" name="s1006"><h2>1.08 XMI</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The XML Metadata Interchange (XMI) is the default serialization
format used by EMF. This format is based on the XMI 2.0
specification from the OMG. This specification may be found at <a
class="" target="new"
href="http://cgi.omg.org/cgi-bin/doc?ad/01-06-12">http://cgi.omg.org/cgi-bin/doc?ad/01-06-12</a>.<br />
 </p>
<p>
 The XML specification may be found at <a class=""
target="new"
href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a>.<br />
 </p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1012" name="s1012"><b
class="section2">1.09 <tt class="code">XMIResource</tt></b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 An <tt class="code">XMIResource</tt> is an extension to the
<tt class="code">Resource</tt> interface (See <a
class="" href="#s1013"><tt class="code">Resource</tt></a>.) that handles a <tt class="code">Resource</tt> whose contents are serialized as an
XMI document. This is the default type of <tt class="code">Resource</tt> used by EMF.
</p>
<p>
 The <tt class="code">XMIResource</tt> interface provides
APIs that enable you to:
<ul>
<li>Access and modify the XMI IDs will be used when objects are
serialized. (Note that IDs are optional. If an object does not have
an ID, references to that object within a document are based on the
relative position of the object. Using IDs can increase the size of
your documents, so their use is not recommended.)</li>
<li>Control whether the XMI documents are stored in zipped form.
The default setting is to use unzipped files.</li>
<li>Specify the XML encoding to be used when saving the <tt class="code">Resource</tt></li>
<li>Specify various save options:</li>
<li>Control whether the type of an element is written using "xmi:type" or "xsi:type". The default is to use "xsi:type"</li>
<li>Control whether the encoded attribute style is used to
serialize an attribute whose value is an <tt class="code">EObject</tt>. When an attribute is serialized
under this option, the value of an attribute is a QName URI pair,
where the QName is optional, depending on whether the referenced
object's type is identical to the feature. When the option is not
specified, an attribute whose value is an <tt class="code">EObject</tt> is serialized as an element.</li>
<li>Determine the line width at which line breaks will be
automatically added.</li>
<li>Determine whether the serialized document will begin
with:<br />
<br />
 &lt;?xml version="1.0" encoding="encoding"?&gt;</li>
<li>Control whether to skip processing for escape characters. This
processing adds overhead that can be skipped if you know for sure
that none of the values of your attributes contain a character that
needs to be escaped. These characters are ampersand (`&amp;'),
double-quote (`"'), less-than(`&lt;`), LF (`\n'), CR (`\r'), and
tab (`\t')</li>
<li>Determine how dangling hrefs will be handled during save. A
dangling href is a cross file reference where the target is not in
a valid <tt class="code">Resource</tt>, which means that the
URI for the target cannot be computed. The possible actions are to
either throw an exception, discard them silently, or record them
and continue.</li>
<li>Specify various load options:</li>
<li>Control whether notifications are to be disabled during
loading.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1007" name="s1007"><h2>1.10 Observers and Notifiers</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 EMF provides a mechanism for attaching observers (also known as
adaptors) to objects (sometimes referred to as notifiers.) The
observers are informed of any changes to the notifiers to which
they are attached. This allows you to extend the behavior of your
EMF objects by implementing observers that provide the extended
behavior and attaching those observers to your EMF objects.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1001" name="s1001"><h1>2 Tasks</h1></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


<ul>
<li>See <a class="" href="#s1015">Defining Your
Model</a>.</li>
<li>See <a class="" href="#s1016">Code Generation Using
Rational Rose</a>.</li>
<li>See <a class="" href="#s1017">Code Generation Using XMI
documents</a>.</li>
<li>See <a class="" href="#s1018">Code Generation Using
Annotated Java Interfaces</a>.</li>
<li>See <a class="" href="#s1019">Generating your
model</a>.</li>
<li>See <a class="" href="#s1020">Configuring your EMF
Runtime Environment</a>.</li>
<li>See <a class="" href="#s1021">Registering/Initializing
a Package</a>.</li>
<li>See <a class="" href="#s1022">Registering a <tt class="code">Resource.Factory</tt></a>.</li>
<li>See <a class="" href="#s1023">Creating a <tt class="code">ResourceSet</tt></a>.</li>
<li>See <a class="" href="#s1024">Creating a <tt class="code">Resource</tt></a>.</li>
<li>See <a class="" href="#s1025">Accessing the Package and
Factory classes</a>.</li>
<li>See <a class="" href="#s1026">Running your
application</a>.</li>
<li>See <a class="" href="#s1027">Creating Instance
Data</a>.</li>
<li>See <a class="" href="#s1028">Serializing Your Instance
Data</a>.</li>
<li>See <a class="" href="#s1029">Loading Instance
Data</a>.</li>
<li>See <a class="" href="#s1030">Handling
notifications</a>.</li>
<li>See <a class="" href="#s1031">Defining
Observers</a>.</li>
<li>See <a class="" href="#s1032">Attaching Observers to
Your Objects</a>.</li>
<li>See <a class="" href="#s1033">Using Reflective
APIs</a>.</li>
<li>See <a class="" href="#s1034">Examining <tt class="code">EObject</tt> Instances using
Reflection</a>.</li>
<li>See <a class="" href="#s1035">Customizing
EMF</a>.</li>
<li>See <a class="" href="#s1036">Creating Keys to Access
the Contents of a <tt class="code">Resource</tt></a>.</li>
<li>See <a class="" href="#s1037">Customizing the <tt class="code">Resource</tt> for non-XMI
Serialization</a>.</li>
<li>See <a class="" href="#s1038">Handling XMI Documents
Serialized from a Different Version of Your Model</a>.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1015" name="s1015"><h2>2.01 Defining Your Model</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The first step in creating an EMF-based application is to define
your model. EMF allows you to express your model in a variety of
ways.
</p>
<p>
 Whichever form you choose, your model specification will consist
of some number of packages, classes, attributes, and associations.
Each of these has various properties that you can specify.
</p>
<p>
 Some properties are mandatory, but most have some default
settings, so you only need to specify them explicitly if you wish
to override the defaults. For example, when you specify an
attribute, the attribute name is required but the multiplicity is
not. (If you do not specify a multiplicity, single-valued is
assumed.)
</p>
<p>
 A complete list of the properties that are applicable to each
model element is provided in the section Ecore Properties and
Codegen Specifications.
</p>
<p>
 For the examples that appear in the following sections, assume
that we wish to create a model that consists of a single package
called "enterprise" with classes that represent companies,
departments, and employees. This details of this model are
illustrate below using UML notation.
</p>

<p style="text-align: center"><a id="fig1" name="fig1"><span
class="jet"><img src="images/EMFUG-1.jpg" width="421"
height="460" border="0"
alt="FIGURE 1. UML for enterprise model" /><br />
FIGURE 1. UML for enterprise model</span></a></p>

<p>
 You have three choices for how you could specify this model to EMF
code generation:</p>
 

<ul>
<li>You can use the UML notation directly. (You will need to use
some special annotations in the form of Rose properties). See <a
class="" href="#s1016">Code Generation Using Rational
Rose</a>.</li>
<li>You can write a file that expresses the classes of the model
using XMI elements. See <a class="" href="#s1017">Code
Generation Using XMI documents</a>.</li>
<li>You can write Java source files that define a Java interface
for each of the classes in the model. (You will need to use some
special annotations in the form of Java comments.) See <a
class="" href="#s1018">Code Generation Using Annotated Java
Interfaces</a>.</li></ul>

<br />
 Note that the comment boxes in Figure 1, UML for enterprise model
indicate that there are implementation details for this model that
cannot be expressed directly in UML. These comments have no impact
on code generation. The actual mechanism that is used to specify
this information to code generation will depend on which code
generation technique you use. These mechanisms are discussed in the
following sections.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1016" name="s1016"><h2>2.02 Code Generation Using Rational
Rose</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 If you use Rational Rose to define your model, you simply draw a
Class Diagram containing Packages, Classes, Attributes, and
Associations. An example of a UML diagram depicting a package is
shown in Figure 1, UML for enterprise model. In general, the UML
elements in your diagram map directly to Ecore elements which
determine the precise code generation patterns to be used.
Additionally, there are a few special annotations that are used by
the EMF basic code generation tool of which you may need to be
aware.
</p>
<p>
 These will be discussed in the following sections:
<ul>
<li>See <a class="" href="#s1039">Basic UML Model
Elements</a>. shows how you specify the most common properties of
classes, attributes, and relationships.</li>
<li>See <a class="" href="#s1040">Specification of Abstract
Classes</a>. shows how an abstract class is specified.</li>
<li>See <a class="" href="#s1041">Attribute Specifications
in UML</a>. shows how you specify operations, datatypes and
enumerations.</li>
<li>See <a class="" href="#s1042">The eCore Properties
Page</a>. shows how you set up your Rose model to include special
ecore properties that are not part of standard UML</li>
<li>See <a class="" href="#s1043">Ecore Properties for
Attributes</a>. shows how you specify ecore properties that apply
to attributes (i.e. transience, volatility, changeability,
settability, and uniqueness.)</li>
<li>See <a class="" href="#s1044">Ecore Properties for
Relationships</a>. shows how you specify ecore properties that
apply to relationships (i.e. transience, volatility, changeability,
settability, and resolveability.)</li>
<li>See <a class="" href="#s1045">Ecore Properties for
Packages</a>. shows how you specify ecore properties that apply to
attributes (i.e. prefix, package name, base package, namespace
prefix and namespace URI.)</li>
<li>See <a class="" href="#s1046">Specifying Multiple
Inheritance in UML</a>. shows how you can specify that a class has
multiple superclasses.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1039" name="s1039"><h2>2.03 Basic UML Model Elements</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The basic elements in your UML model are Classes, Attributes and
Relationships. For example:
</p>

<p style="text-align: center"><a id="fig2" name="fig2"><span
class="jet"><img src="images/EMFUG-2.jpg" width="408"
height="267" border="0"
alt="FIGURE 2. Basic Ecore elements in UML diagram" /><br />
FIGURE 2. Basic Ecore elements in UML diagram</span></a></p>

<p> In most cases, the code generation utility will create a Java
interface and a Java implementation class for each UML class. Each
interface will have accessor methods to get and set each of the
attributes and relationships specified in the model. For example,
the Company class shown in Figure 2, Basic Ecore elements in UML
diagram will generate a Java interface named Company and a Java
class named CompanyImpl.
</p>
<p>
 The accessor methods that are created for each attribute and
association will vary depending on the properties of the
corresponding UML elements.
<ul>
<li>Single-valued attributes and navigable relationships will
generate a get() method 1 that returns a value of the appropriate
type and a set() method that accepts a parameter of that
type.</li>
<li>Multi-valued attributes and navigable relationships will
generate only a get() method that returns an EList. The actual
implementation of the EList that is returned is constrained to only
accept values of the appropriate type.</li>
<li>For relationships, the implementation of the set() method (in
the case of single-valued relationships) or the EList (in the case
of multi-valued relationships) will be different depending on
whether the relationship uses containment. In particular, the
implementation of a containment relationship will enforce the
semantics that an instance of an object can only have a single
container.</li>
<li>Relationships that are not navigable will not result in the
generation of any accessor methods.</li>
<li>If you specify an inheritance relationship in your model, the
resulting generated interface and implementation class will have
the same inheritance structure.</li></ul>

<br />
 For example, the Company class has a single-valued attribute
called "name", two single-valued relationships called "employeeOfTheMonth" and "parent", and two multi-valued
relationships called "department" and " subsidiary. Therefore the
generated Company interface will include the following:
<pre>
   public interface Company extends <tt class="code">EObject</tt>{
      String getName();
      void setName(String value);
      EList getDepartment();
      Employee getEmployeeOfTheMonth();
      void setEmployeeOfTheMonth(Employee value);
      Company getParent();
      void setParent(Company);
      EList getSubsidiary();
   } // Company
</pre>

 Note that the "department" relationship on the Company class is
a containment relationship while the "subsidiary" relationship is
non-containment. Both of these relationships are multi-valued,
which means they generated interface has a get method but no set
method. The difference in the containment property leads to
different implementations for the generated get() methods. For
example, the generated CompanyImpl class will include the following
methods:
<pre>
   public EList getDepartment() {
      if (department == null) {
      department =
      new <tt class="code">EObject</tt>ContainmentWithInverseEList(
         Department.class,
         this,
         EnterprisePackage.COMPANY__DEPARTMENT,
         EnterprisePackage.DEPARTMENT__COMPANY);
      }
      return department;
   }
   public EList getSubsidiary() {
      if (subsidiary == null) {
      subsidiary =
      new <tt class="code">EObject</tt>WithInverseResolvingEList(
         Company.class,
         this,
         EnterprisePackage.COMPANY__SUBSIDIARY,
         EnterprisePackage.COMPANY__PARENT);
      }
      return subsidiary;
   }
</pre>

 The Employee class inherits from the Person class. Therefore, the
first line of the interface for Employee will start with:
<pre>
   public interface Employee extends Person
</pre>

 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1040" name="s1040"><h2>2.04 Specification of Abstract
Classes</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 Note that the Person class is marked with the
&lt;&lt;Abstract&gt;&gt; stereotype. This stereotype is only used
in the UML for informational purposes to indicate that the Abstract
property is set for this class. This property is set via the Detail
page of the Specification dialog for the cass. For example:
</p>

<p style="text-align: center"><a id="fig3" name="fig3"><span
class="jet"><img src="images/EMFUG-3.jpg" width="268"
height="343" border="0"
alt="FIGURE 3. Specification Dialog for the Person Class" /><br />
FIGURE 3. Specification Dialog for the Person Class</span></a></p>


<ul>
<li>If you specify the Abstract property in your UML, the resulting
generated implementation class will be abstract.</li></ul>

<br />
 For example, the declaration for PersonImpl will be:
<ul>
<li>public abstract class PersonImpl extends <tt class="code">EObjectImpl</tt> implements Person</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1041" name="s1041"><h2>2.05 Attribute Specifications in UML</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>

<p>
 The are some special conventions used by EMF to define the types
of certain attributes. Consider the following segment of the
enterprise package:
</p>

<p style="text-align: center"><a id="fig4" name="fig4"><span
class="jet"><img src="images/EMFUG-4.jpg" width="451"
height="378" border="0"
alt="FIGURE 4. Enumerations, DataTypes, and Default Values" /><br />
 FIGURE 4. Enumerations, DataTypes, and Default
Values</span></a></p>


<ul>
<li>If you specify an initial value in your UML, the resulting
attribute will be initialized with the specified value</li>
<li>If you specify an operation, the resulting interface will
include the signature for that operation and the implementation
class will have a stub method. (The generated implementation of the
stub method will throw a UnsupportedOperationException, so you will
need to modify this method by hand after code generation.)</li>
<li>If you need to refer to a type that is not an EMF class in your
model, you can declare that type using a &lt;&lt;datatype&gt;&gt;
stereotype. UML classes with this stereotype do not generate any
code. Note that this class must include a single attribute that
defines the underlying type. The attribute should be flagged with a
stereotype of &lt;&lt;javaclass&gt;&gt;.</li>
<li>If you wish to define an enumeration, you can do so using a UML
class with the &lt;&lt;enumeration&gt;&gt; stereotype. This results
in the generation of a final class that has static final fields
that represent the enumeration values and enumeration literal
instances. The accessor methods for attributes of this enumeration
type pass the literal instances that are defined in this
class.</li></ul>

<br />
 The Employee class has a "dateOfHire" attribute whose type is
the datatype "Date" and an "employmentType" attribute whose
type is the enumeration "EmploymentType". Therefore, the Employee
interface will include the following methods:
<pre>
   Date getDateOfHire();
   void setDateOfHire(Date value);
   EmploymentType getEmploymentType();
   void setEmploymentType(EmploymentType value);
   void initiateLeave(Date startDate);
</pre>
 The EmploymentType interface is generated as follows:
<pre>
   public final class EmploymentType extends AbstractEnumerator
   {
      public static final int FULL_TIME = 0;
      public static final int PART_TIME = 1;
      public static final int ON_LEAVE = 2;
      public static final EmploymentType FULL_TIME_LITERAL =
      new EmploymentType(FULL_TIME, "FullTime");
      public static final EmploymentType PART_TIME_LITERAL =
      new EmploymentType(PART_TIME, "PartTime");
      public static final EmploymentType ON_LEAVE_LITERAL =
      new EmploymentType(ON_LEAVE, "OnLeave");
      public static final List VALUES =
      Collections.unmodifiableList(Arrays.asList(VALUES_ARRAY));
      public static EmploymentType get(String name)
      {...}
      public static EmploymentType get(int value)
      {...}
      private EmploymentType(int value, String name)
      {
         super(value, name);
      }
      
   } //EmploymentType
</pre>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1042" name="s1042"><h2>2.06 The eCore Properties Page</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>

<p>
 In some cases there are properties that are required for code
generation that cannot be expressed in standard UML. For these
cases, EMF provides a special Rose properties file called
ecore.pty. These properties are not shown explicitly in the example
in Figure 1, although annotations are used in the diagram to
indicate that the properties have been defined.
</p>
<p>
 Before you can use these properties, you must first add the
appropriate model properties file to your Rose model. This file is
the ecore.pty file that is shipped in the org.eclipse.emf.ecore
plugin in the src\models directory.
</p>
<p>
 The mechanism for adding these properties to your model is shown
in Figure 5, Adding a Properties File to Your Model and Figure 6,
Selecting the eCore.pty file.
</p>

<p style="text-align: center"><a id="fig5" name="fig5"><span
class="jet"><img src="images/EMFUG-5.jpg" width="222"
height="156" border="0"
alt="FIGURE 5. Adding a Properties File to Your Model" /><br />
FIGURE 5. Adding a Properties File to Your Model</span></a></p>

<br />
<br />
 

<p style="text-align: center"><a id="fig6" name="fig6"><span
class="jet"><img src="images/EMFUG-6.jpg" width="331"
height="223" border="0"
alt="FIGURE 6. Selecting the eCore.pty file" /><br />
FIGURE 6. Selecting the eCore.pty file</span></a></p>

<br />
<br />
 In order to see a particular property, you need to open up the
specifications page for the object to which the property applies.
The various properties are illustrated in
<ul>
<li>Ecore Properties for Attributes</li>
<li>Ecore Properties for Relationships</li>
<li>Ecore Properties for Packages</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1043" name="s1043"><h2>2.07 Ecore Properties for Attributes</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>

<p>
 The following figure illustrates the eCore Properties page for
Attributes:
</p>

<p style="text-align: center"><a id="fig7" name="fig7"><span
class="jet"><img src="images/EMFUG-7.jpg" width="270"
height="331" border="0"
alt="FIGURE 7. Properties page for the yearsOfService attribute" /><br />
 FIGURE 7. Properties page for the yearsOfService
attribute</span></a></p>

<ul>
<li>If isTransient is True, the attribute or relationship will not
be stored.</li>
<li>If isVolatile is True, the attribute or relationship will not
have any storage associated with it and the generated
implementations of the get() and set() method for the attribute or
relationship will throw an UnsupportedOperationException. (In other
words, you will need to implement these methods explicitly.)</li>
<li>If isChangeable is True, no set() method is generated for the
attribute or association.</li>
<li>If isUnsettable is True, isSet() and unset() methods are
generated for the attribute or association. (Note that this
requires additional runtime storage for each such attribute or
association.)</li>
<li>If isUnique is True for an attribute that has multi-valued
multiplicity, uniqueness semantics are enforced for the list that
holds the attribute values.</li></ul>

<p> In the case of the yearsOfService attribute shown here, the
intention is to implement the attribute to be derived from the
dateOfHire attribute and from current date when the application is
run. The settings on the ecore properties page instruct code
generation to omit the default implementation of the get method
from the implementation class ( isVolatile=True ), to omit the set
method altogether from the interface ( isChangeable=False ), and to
mark the attribute as transient so it will not be serialized (
isTransient=True.)
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1044" name="s1044"><h2>2.08 Ecore Properties for
Relationships</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The following figure shows the specification dialog for the
employeeOfTheMonth association. It is opened to the eCore A page,
which displays that Ecore attributes that apply to the
employeeOfTheMonth role of the association.
</p>

<p style="text-align: center"><a id="fig8" name="fig8"><span
class="jet"><img src="images/EMFUG-8.jpg" width="269"
height="359" border="0"
alt="FIGURE 8. Properties page for the employeeOfTheMonth association" /><br />
 FIGURE 8. Properties page for the employeeOfTheMonth
association</span></a></p>

<br />
<br />
 For the most part, the properties that apply to attributes also
apply to relationships. (See <a class=""
href="#fig7">Figure 7</a>: Properties page for the yearsOfService
attribute.) The exceptions are that the isUnique property only
applies to attributes and that the isResolveProxies property only
applies to relationships.
<ul>
<li>If isResolveProxies is False for a relationship, the two ends
of a relationship would typically not be stored in separate
documents. If they are stored in separate documents, you will need
to resolve the proxies manually.</li></ul>

<p> In the case of the employeeOfTheMonth relationship shown here, the
intention is that the indicated employee must be one of the
employees that contained in the company. Therefore, it will not be
necessary to allow for the possibility that the target of this
relationship is in a different XMI document from the source.
Setting the isResolveProxies property to False suppresses the
generated code that would attempt to resolve proxies when accessing
this relationship, which makes the accessor method more efficient
than it would otherwise be.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1045" name="s1045"><h2>2.09 Ecore Properties for Packages</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The following figure illustrate the eCore page of the
Specification dialog for Packages.
</p>

<p style="text-align: center"><a id="fig9" name="fig9"><span
class="jet"><img src="images/EMFUG-9.jpg" width="268"
height="331" border="0"
alt="FIGURE 9. Ecore Properties Page for the Package" /><br />
FIGURE 9. Ecore Properties Page for the Package</span></a></p>


<ul>
<li>If prefix is specified, the value is used as the prefix for
constructing the name of the Package and Factory interfaces and
classes. Otherwise, the capitalized package name is used to
construct these names.</li>
<li>If packageName is specified, the value is used for the
rightmost part of the name of the generated Java package.
Otherwise, the package name is used.</li>
<li>If basePackage is specified, the value is used for the
qualifier for the generated Java package.</li>
<li>If nsPrefix is specified, the value is used as the namespace
prefix for any XMI documents that contain instances of classes from
this package. Otherwise, the package name is used.</li>
<li>If nsURI is specified, the value is used as the namespace URI
for any XMI documents that contain instances of or associations to
classes from this package.</li></ul>

<p>
 In this example, there is no prefix. There is also no packageName,
so the default name will be the name of the package, which is "enterprise". The basePackage is <tt>org.eclipse.emf.samples</tt>.
Therefore the fully qualified name of the generated package
interface will be <tt>org.eclipse.emf.samples.enterprise.EnterprisePackage.java</tt>.
</p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1046" name="s1046"><h2>2.10 Specifying Multiple Inheritance in
UML</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>

<p>
 EMF supports multiple inheritance of interfaces in much the same
way that multiple inheritance is supported in Java. You can define
a class in UML that inherits from more than one superclass. The
code that is generated for this class will include an interface
that extends all the interfaces corresponding to the specified
superclasses, but the implementation class will only extend one of
the implementation classes.
</p>
<p>
 This means that a generated class may not define all the methods
that it is required to implement based on the interfaces that the
class supports. You will need to make sure that an implementation
is provided for any method that is missing.
</p>
<p>
 You can specify which superclass is the primary superclass in your
UML by attaching a stereotype to the generalization relationship
that appears in your model. A stereotype of &lt;&lt;extends&gt;&gt;
indicates the primary superclass and a stereotype of
&lt;&lt;mixin&gt;&gt; indicates some other superclass. For a given
subclass, there can only be one generalization that carries the
&lt;&lt;extends&gt;&gt; stereotype.
</p>
<p>
 For example:
</p>

<p style="text-align: center"><a id="fig10" name="fig10"><span
class="jet"><img src="images/EMFUG-10.jpg" width="223"
height="184" border="0"
alt="FIGURE 10. UML for Multiple Inheritance" /><br />
FIGURE 10. UML for Multiple Inheritance</span></a></p>

<br />
<br />
 In this model, class A has two superclasses, B and C. The
generated interface, A, will start with:
<pre>
        public interface A extends B, C
</pre>

while the generated implementation class, AImpl, will begin with: 

<pre>
        public class AImpl extends BImpl implements A
</pre>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1017" name="s1017"><h2>2.11 Code Generation Using XMI
documents</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>

<p>
 You can also write XMI documents that can fully specify your
model. There are two different types of XMI documents that are
needed to specify a model:
<ul>
<li>There will be one ecore document for each package in your
model. This document contains the detailed definitions of all the
packages and classes in your model. The elements of the ecore
document are the classes and attributes of the Ecore model. The
details for specifying the XMI document are discussed in Ecore
Properties and Codegen Specifications. The extension for the ecore
documents should be ".ecore".</li></ul>

<br />
 The ecore document contains classes that are defined in the Ecore
model that is used by the org.eclipse.emf.ecore plugin.
<ul>
<li>There will be one genmodel document for the entire model. This
document is the input to the code generation utility. It has
references to elements defined in the ecore documents and also
includes some additional information needed for code generation
that is not part of the model. (For example, information about how
names should be constructed.) The extension for the genmodel
documents is ".genmodel"</li></ul>

<br />
 The genmodel document contains classes that are defined in the
GenModel model that is used by the org.eclipse.emf.codegen.ecore
plugin.
</p>
<p>
 The following sections illustrate the contents of the genmodel and
ecore documents that are used to specify the enterprise model show
in Figure 1, UML for enterprise model. (Note that for this example,
the model consists of only a single package, hence there is only
one ecore document. If the model were to include multiple root
packages, there would be one ecore document for each
package.)
</p>
<p>
 The enterprise.genmodel document is shown in Genmodel Document for
the enterprise Model. See <a class=""
href="#s1048">Genmodel Document for the enterprise Model</a>.
</p>
<p>
 The main elements of the enterprise.ecore document are shown in
the following sections. (Note that these elements are, in fact, all
part of a single document. They are separated into the various
sections below to help direct your attention to the salient
features of each element.)
<ul>
<li>See <a class="" href="#s1049">The Enterprise Package
Element in the Ecore Document</a>.</li>
<li>See <a class="" href="#s1050">The Company Class Element
in the Ecore Document</a>.</li>
<li>See <a class="" href="#s1051">The Department Class
Element in the Ecore Document</a>.</li>
<li>See <a class="" href="#s1052">The Person Class Element
in the Ecore Document</a>.</li>
<li>See <a class="" href="#s1053">The Employee Class
Element in the Ecore Document</a>.</li>
<li>See <a class="" href="#s1054">The EmploymentType
Enumeration Element in the Ecore Document</a>.</li>
<li>See <a class="" href="#s1055">The Date Datatype Element
in the Ecore Document</a>.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1048" name="s1048"><h2>2.12 Genmodel Document for the enterprise
Model</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The genmodel document is the document that ties together all the
packages, classes, and features in a model and provides any
additional information that is not in the model but that is needed
by the code generation utility to produce the appropriate source
code.
<pre>
   &lt;?xml version="1.0" encoding="ASCII"?&gt;
   &lt;genmodel:GenModel xmi:version="2.0" xmlns:xmi="<a
class="" target="new"
href="http://www.omg.org/XMI">http://www.omg.org/XMI</a>" 
      xmlns:ecore="<a class="" target="new"
href="http://www.eclipse.org/emf/2002/Ecore">http://www.eclipse.org/emf/2002/Ecore</a>"
      xmlns:genmodel="<a class="" target="new"
href="http://www.eclipse.org/emf/2002/GenModel">http://www.eclipse.org/emf/2002/GenModel</a>"
      modelDirectory="/org.eclipse.emf.samples/src"
      editDirectory="/org.eclipse.emf.samples.edit/src" 
         editorDirectory="/org.eclipse.emf.samples.editor/src"
      modelPluginID="org.eclipse.emf.samples.enterprise"&gt;

   &lt;foreignModel&gt;C:\emf\eclipse\plugins\org.eclipse.emf.samples\
      src\model\enterprise.mdl&lt;/foreignModel&gt;
   &lt;genPackages prefix="Enterprise" basePackage="org.eclipse.emf.samples"
      ecorePackage="enterprise.ecore#/"&gt;
   &lt;genEnums ecoreEnum="enterprise.ecore#//EmploymentType"&gt;
      &lt;genEnumLiterals 
         ecoreEnumLiteral="enterprise.ecore#//EmploymentType/FullTime"/&gt;
      &lt;genEnumLiterals 
         ecoreEnumLiteral="enterprise.ecore#//EmploymentType/PartTime"/&gt;

      &lt;genEnumLiterals 
         ecoreEnumLiteral="enterprise.ecore#//EmploymentType/OnLeave"/&gt;
   &lt;/genEnums&gt;
   &lt;genDataTypes ecoreDataType="enterprise.ecore#//Date"/&gt;
   &lt;genClasses ecoreClass="enterprise.ecore#//Department"&gt;
      &lt;genFeatures ecoreFeature="ecore:EAttribute
    enterprise.ecore#//Department/number"/&gt;
      &lt;genFeatures ecoreFeature="ecore:EReference
    enterprise.ecore#//Department/company"/&gt;

      &lt;genFeatures ecoreFeature="ecore:EReference
    enterprise.ecore#//Department/employee"/&gt;
   &lt;/genClasses&gt;
   &lt;genClasses ecoreClass="enterprise.ecore#//Company"&gt;
      &lt;genFeatures ecoreFeature="ecore:EAttribute
    enterprise.ecore#//Company/name"/&gt;
      &lt;genFeatures ecoreFeature="ecore:EReference
    enterprise.ecore#//Company/department"/&gt;
      &lt;genFeatures ecoreFeature="ecore:EReference
    enterprise.ecore#//Company/parent"/&gt;

      &lt;genFeatures ecoreFeature="ecore:EReference
    enterprise.ecore#//Company/subsidiary"/&gt;
      &lt;genFeatures ecoreFeature="ecore:EReference 
         enterprise.ecore#//Company/employeeOfTheMonth"/&gt;
   &lt;/genClasses&gt;
   &lt;genClasses ecoreClass="enterprise.ecore#//Person"&gt;
      &lt;genFeatures ecoreFeature="ecore:EAttribute
    enterprise.ecore#//Person/comments"/&gt;
      &lt;genFeatures ecoreFeature="ecore:EAttribute
    enterprise.ecore#//Person/name"/&gt;

   &lt;/genClasses&gt;
   &lt;genClasses ecoreClass="enterprise.ecore#//Employee"&gt;
      &lt;genFeatures ecoreFeature="ecore:EAttribute
    enterprise.ecore#//Employee/manager"/&gt;
      &lt;genFeatures ecoreFeature="ecore:EAttribute
    enterprise.ecore#//Employee/email"/&gt;
      &lt;genFeatures ecoreFeature="ecore:EAttribute
    enterprise.ecore#//Employee/employmentType"/&gt;
      &lt;genFeatures ecoreFeature="ecore:EAttribute
    enterprise.ecore#//Employee/dateOfHire"/&gt;

      &lt;genFeatures ecoreFeature="ecore:EAttribute
    enterprise.ecore#//Employee/yearsOfService"/&gt;
      &lt;genFeatures ecoreFeature="ecore:EAttribute
    enterprise.ecore#//Employee/leaveOfAbsenceStart"/&gt;
      &lt;genFeatures ecoreFeature="ecore:EReference
    enterprise.ecore#//Employee/department"/&gt;
      &lt;genOperations 
         ecoreOperation="enterprise.ecore#//Employee/initiateLeave"&gt;
         &lt;genParameters 
            ecoreParameter="enterprise.ecore#//Employee/initiateLeave/startDate"/&gt;
      &lt;/genOperations&gt;

   &lt;/genClasses&gt;
   &lt;/genPackages&gt;
   &lt;/genmodel:GenModel&gt;  
</pre>

Note that most of the elements of this document consist entirely of
references into the enterprise.ecore document, which is described
in the following sections.
</p>
<p>
 The elements in this document that may contain additional
information are the genmodel:GenModel element and the genPackages
element.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1049" name="s1049"><h2>2.13 The Enterprise Package Element in the Ecore
Document</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 A package is specified as an ecore:<tt class="code">EPackage</tt> element in an ecore document.
<pre>
   &lt;?xml version="1.0" encoding="ASCII"?&gt;
   &lt;ecore:<tt class="code">EPackage</tt> xmi:version="2.0" 
      xmlns:xmi="<a class="" target="new"
href="http://www.omg.org/XMI">http://www.omg.org/XMI</a>"
   xmlns:xsi="<a class="" target="new"
href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>"
   xmlns:ecore="<a class="" target="new"
href="http://www.eclipse.org/emf/2002/Ecore">http://www.eclipse.org/emf/2002/Ecore</a>" name="enterprise"
   nsURI="<a class="" target="new"
href="http:///enterprise.xmi">http:///enterprise.xmi</a>" nsPrefix="enterprise"&gt;

   &lt;<tt class="code">EClassifiers</tt>... &gt;
   ..
   &lt;/<tt class="code">EClassifiers</tt>&gt;
   &lt;/ecore:<tt class="code">EPackage</tt>&gt;
</pre>

In this case we are defining a package whose name is "enterprise".
The details for the <tt class="code">EClassifiers</tt> that
comprise this package are illustrated in the following
sections.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1050" name="s1050"><h2>2.14 The Company Class Element in the Ecore
Document</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 A class is specified as an ecore:<tt class="code">EClass</tt> element in an XMI document. For
example, the XMI that defines the Company class from the Enterprise
model is:
<pre>
   &lt;<tt class="code">EClassifiers</tt> xsi:type="ecore:<tt class="code">EClass</tt>" 
      name="Company"&gt;
   &lt;eReferences name="department" eType="#//Department" upperBound="-1"
   containment="true" eOpposite="#//Department/company"/&gt;
   &lt;eReferences name="employeeOfTheMonth" eType="#//Employee"
   resolveProxies="false"/&gt;
   &lt;eReferences name="parent" eType="#//Company"
   eOpposite="#//Company/subsidiary"/&gt;

   &lt;eReferences name="subsidiary" eType="#//Company" upperBound="-1"
   eOpposite="#//Company/parent"/&gt;
   &lt;eAttributes name="name"
   eType="ecore:EDataType <a class="" target="new"
href="http://www.eclipse.org/emf/2002/Ecore#//EString">http://www.eclipse.org/emf/2002/Ecore#//EString</a>"/&gt;
   &lt;/<tt class="code">EClassifiers</tt>&gt;
</pre>

Note the following:
<ul>
<li>When no lowerBound is specified, "0" is assumed. When no
upperBound is specified "1" is assumed. In the above example, the
employeeOfTheMonth and parent references and the name attribute use
both defaults, and therefore are single-valued. This means that
code generation will generate get() and set() methods for these
features.</li>
<li>An upperBound that is set to "-1" (as in the department and
subsidiary references) indicates that there is no upper bound. This
implies that the cardinality is multi-valued. Therefore no set()
method will be generated and that the get() method will return an
EList.</li>
<li>The eOpposite attribute identifies the opposite end of a
relationship that is navigable in both directions. (For example,
the department reference specifies an eOpposite attribute while the
employeeOfTheMonth reference does not.) The eOpposite attribute is
needed so that the generated code will ensure that when one end of
a relationship is modified, the other end will be updated
accordingly.</li>
<li>When the resolveProxies attribute is set to "false", (see the
employeeOfTheMonth reference), the generated get() method will
assume that the target object is never a proxy, and therefore will
not attempt to resolve the target. This improves the performance of
the get() method, but it should only be used if you are sure that
the target oar a reference will never be stored in a different
document from the source.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1051" name="s1051"><h2>2.15 The Department Class Element in the Ecore
Document</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The XMI that defines the Department class from the Enterprise
model is:
<pre>
   &lt;<tt class="code">EClassifiers</tt> xsi:type="ecore:<tt class="code">EClass</tt>" 
      name="Department"&gt;
   &lt;eReferences name="company" eType="#//Company" transient="true"
   eOpposite="#//Company/department"/&gt;
   &lt;eReferences name="employee" eType="#//Employee" upperBound="-1"
   containment="true" eOpposite="#//Employee/department"/&gt;

   &lt;eAttributes name="number"
   eType="ecore:EDataType <a class="" target="new"
href="http://www.eclipse.org/emf/2002/Ecore#//EInt">http://www.eclipse.org/emf/2002/Ecore#//EInt</a>"/&gt;
   &lt;/<tt class="code">EClassifiers</tt>&gt;
</pre>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1052" name="s1052"><h2>2.16 The Person Class Element in the Ecore
Document</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 An abstract class is specified as an ecore:<tt class="code">EClass</tt> element in an XMI document where the
abstract attribute is set to "true". For example, the XMI that
defines the Person class from the Enterprise model is
<pre>
   &lt;<tt class="code">EClassifiers</tt> xsi:type="ecore:<tt class="code">EClass</tt>" 
      name="Person" abstract="true"&gt;
   &lt;eAttributes name="comments"
   eType="ecore:EDataType <a class="" target="new"
href="http://www.eclipse.org/emf/2002/Ecore#//EString">http://www.eclipse.org/emf/2002/Ecore#//EString</a>"
   upperBound="-1"/&gt;

   &lt;eAttributes name="name"
   eType="ecore:EDataType <a class="" target="new"
href="http://www.eclipse.org/emf/2002/Ecore#//EString">http://www.eclipse.org/emf/2002/Ecore#//EString</a>"/&gt;
   &lt;/<tt class="code">EClassifiers</tt>&gt;
</pre>

Note the following:
<ul>
<li>The abstract="true" attribute will cause code generation to add
the abstract keyword to the generated implementation class.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1053" name="s1053"><h2>2.17 The Employee Class Element in the Ecore
Document</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The XMI that defines the Employee class from the Enterprise model
is:
<pre>
   &lt;<tt class="code">EClassifiers</tt> xsi:type="ecore:<tt class="code">EClass</tt>" 
      name="Employee" eSuperTypes="#//Person"&gt;

   &lt;eOperations name="initiateLeave"&gt;
   &lt;eParameters name="startDate" eType="#//Date"/&gt;
   &lt;/eOperations&gt;
   &lt;eReferences name="department" eType="#//Department" transient="true" 
      eOpposite="#//Department/employee"/&gt;
   &lt;eAttributes name="manager" 
      eType="ecore:EDataType <a class="" target="new"
href="http://www.eclipse.org/emf/2002/Ecore#//EBoolean">http://www.eclipse.org/emf/2002/Ecore#//EBoolean</a>"
      defaultValueLiteral="false"/&gt;

   &lt;eAttributes name="email" 
      eType="ecore:EDataType <a class="" target="new"
href="http://www.eclipse.org/emf/2002/Ecore#//EString">http://www.eclipse.org/emf/2002/Ecore#//EString</a>"/&gt;
   &lt;eAttributes name="employmentType" 
      eType="#//EmploymentType" defaultValueLiteral="FullTime"/&gt;
   &lt;eAttributes name="dateOfHire" eType="#//Date"/&gt;
   &lt;eAttributes name="yearsOfService" 
      eType="ecore:EDataType <a class="" target="new"
href="http://www.eclipse.org/emf/2002/Ecore#//EInt">http://www.eclipse.org/emf/2002/Ecore#//EInt</a>"
      changeable="false" volatile="true" transient="true"/&gt;
   &lt;eAttributes name="leaveOfAbsenceStart" eType="#//Date" unsettable="true"/&gt;

   &lt;/<tt class="code">EClassifiers</tt>&gt;
</pre>

Note the following:
<ul>
<li>The eSuperTypes="#//Person" attribute means that the generated
code for the Employee interface will extend the Person interface
and that the EmployeeImpl class will extend the PersonImpl
class.</li>
<li>The changeable="false" attribute (see yearsOfService ) will
mean that no set() method will be generated for the attributes and
references to which it applies.</li>
<li>The volatile="true" attribute (see yearsOfService ) will mean
that no storage will be reserved for the attributes and references
to which it applies and also that the generated get() and set()
methods will throw an UnsupportedOperationException.</li>
<li>The transient="true" attribute (see yearsOfService ) will mean
that the attributes and references to which it applies will not be
serialized.</li>
<li>The data type of each attribute and reference is specified
through the eType attribute. For primitive types, the value of
eType is a type that is defined in the ecore model (e.g.
"ecore:EDataType <a class="" target="new"
href="http://www.eclipse.org/emf/2002/Ecore#//EString">http://www.eclipse.org/emf/2002/Ecore#//EString</a>"
). In the case of the employmentType and dateOfHire attributes, the
value of eType are types that are defined in the enterprise package
(e.g. "#//EmploymentType" and "#//Date".)</li>
<li>The defaultValueLiteral attribute (see manager and
employmentType ) provide the initial value that the attribute will
have if it has not been explicitly set.</li>
<li>The unsettable="true" attribute (see leaveOfAbsenceStart ) will
mean that the generated interface will include unset() and isSet()
methods for the attribute to which it applies. (The use of
unsettable="true" incurs some runtime overhead due to the fact that
the implementation for this will require an additional field to
remember whether or not the attribute has been set.)</li>
<li>The eOperations element (which defines the initiateLeave
method) means that the indicated method will be will generated in
the interface and implementation class. The generated EmployeeImpl
class will include a stub implementation of this method. The stub
implementation will throw an UnsupportedOperationException.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1054" name="s1054"><b
class="section2">2.18 The EmploymentType Enumeration Element<br />
<br />
 in the Ecore Document</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 An enumeration is specified as an ecore:EEnum element in an XMI
document. For example, the XMI that defines the EmploymentType
enumeration from the Enterprise model is:
<pre>
   &lt;<tt class="code">EClassifiers</tt> xsi:type="ecore:EEnum" name="EmploymentType"&gt;

   &lt;eLiterals name="FullTime"/&gt;
   &lt;eLiterals name="PartTime" value="1"/&gt;
   &lt;eLiterals name="OnLeave" value="2"/&gt;
   &lt;/<tt class="code">EClassifiers</tt>&gt;
</pre>

Note the following:
<ul>
<li>The eLiterals elements identify the literals that comprise this
enumeration.</li>
<li>Each value attribute should be unique. (The literal named
FullTime uses the default for value which is "0".)</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1055" name="s1055"><h2>2.19 The Date Datatype Element in the Ecore
Document</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 A datatype is specified as an ecore:EDataType element in an XMI
document. For example, the XMI that defines the Date datatype from
the Enterprise model is:
<pre>
   &lt;<tt class="code">EClassifiers</tt> xsi:type="ecore:EDataType" 
      name="Date" instanceClassName="java.util.Date"/&gt;
</pre>

Note the following:
<ul>
<li>The instanceClassName attribute identifies the java interface
or class to which the datatype maps.</li>
</ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1018" name="s1018"><h2>2.20 Code Generation Using Annotated Java
Interfaces</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 If you prefer to use Java interfaces to specify your model, all
you need to do is to write a Java interface declaration to
represent each class in your model and a Java class declaration to
define each enumeration in your model.
</p>
<p>
 Within each interface you will need to specify a get() method for
each attribute or relationship in the model and within each class
you will need to specify a field to represent each enumeration
literal.
</p>
<p>
 Each of these interface statements, class statements, get()
methods, and fields should be preceded by a javadoc comment that
includes a @model tag. This tag is used to tell the code generation
utility that the construct represents an element of your
model.
</p>
<p>
 The code generation utility will automatically expand your
interface declarations to include any other methods that are needed
to represent and access the classes in your model. All the
necessary implementation classes will also be generated
automatically.
</p>
<p>
 Much of the information that is needed to generate code can be
gleaned from the Java interface specification. For example, the
name of the package that a class belongs to is derived from the
package statement that appears in the corresponding interface
declaration. Also, the names of all attributes are derived by
stripping off the prefix "get" from the method names. For
single-valued attributes and references, the type is the return
type of the get() method. Multi-valued attributes and references
are identified by methods that have a return type of List or
EList.
</p>
<p>
 Ecore properties that cannot be derived from the Java source code
can be expressed via the @model tags. Each property is specified in
the form:
<pre>
   /**
      @model [&lt;property&gt;=&lt;value&gt;...]
   */
</pre>

A full list of the possible properties can be found in See <a
class="" href="#s1056">Ecore Properties and Codegen
Specifications</a>.
</p>
<p>
 Examples of the @model tags that are needed to specify the
enterprise model illustrated in Figure 1, UML for enterprise model
can be found in the following sections:
</p>
<p>
 

<blockquote>See <a class="" href="#s1057">Java
Specification for the Enterprise Package</a>.<br />
<br />
 See <a class="" href="#s1058">Java Specification for the
Company Class</a>.<br />
<br />
 See <a class="" href="#s1059">Java Specification for the
Department Class</a>.<br />
<br />
 See <a class="" href="#s1060">Java Specification for the
Person Class</a>.<br />
<br />
 See <a class="" href="#s1061">Java Specification for the
Employee Class</a>.<br />
<br />
 See <a class="" href="#s1062">Java Specification for the
EmploymentType Enumeration</a>.<br />
<br />
</blockquote>

<br />
<br />
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1057" name="s1057"><h2>2.21 Java Specification for the Enterprise
Package</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 In certain cases, it may be useful to provide a interface to
define a package. Note that usually, this declaration is not
required at all. The classes and enumerations that belong to the
package in your model are automatically identified based on the
interface and class declarations that are in a java package. The
datatypes that belong to your package are identified by attributes
and methods that use types that are not classes in your
model.
</p>
<p>
 The only situation where it may be necessary to provide the
declaration shown here is when you wish to override some the
default settings for the package or when you wish to define a
datatype that is not actually referenced in your model.
<pre>
   package org.eclipse.emf.samples.enterprise;
   public interface EnterprisePackage extends <tt class="code">EPackage</tt>{
   String eNAME = "enterprise";
   String eNS_URI = "enterprise.xmi";
   String eNS_PREFIX = "enterprise";
   /**
     @model instanceClass="java.util.Date"
   */
   <tt class="code">EDataType</tt> getDate();
   } //EnterprisePackage
</pre>

Note the following:
<ul>
<li>The eNAME, eNS_URI, and eNS_PREFIX shown here are not actually
required in this case because the indicated values are in fact the
default values that would normally be generated based on the
package statement.</li>
<li>A get method in the package interface that has an @model tag
and that has a return type of org.eclipse.emf.ecore.<tt class="code">EDataType</tt> represents a datatype in your
model. The instanceClass attribute on the @model tag identifies the
java interface or class to which the datatype maps.</li>
<li>Note that the classes and enumerations that are part of the
package do not have to be specified explicitly. The EMF code
generation utility will automatically determine the rest of the
contents of the package based on the other interfaces and classes
that are processed.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1058" name="s1058"><h2>2.22 Java Specification for the Company
Class</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 A class in your model is specified as a Java interface. The name
of the class is the name of the interface. The attributes and
references in the class are represented by get() methods in your
interface that are preceded by a @model tag.
</p>
<p>
 For example, the Java interface that defines the Company class
from the Enterprise model is:
<pre>
   package org.eclipse.emf.samples.enterprise;
   import org.eclipse.emf.common.util.EList;
   import org.eclipse.emf.ecore.<tt class="code">EObject</tt>;
   /**
     @model
   */
   public interface Company extends <tt class="code">EObject</tt>{
   /**
     @model
   */
   String getName();
   /**
     @model type="Department" opposite="company" containment="true"
   */
   EList getDepartment();
   /**
     @model resolveProxies="false"
   */
   Employee getEmployeeOfTheMonth();
   /**
     @model opposite="subsidiary"
   */
   Company getParent();
   /**
     @model type="Company" opposite="parent"
   */
   EList getSubsidiary();
   } // Company
</pre>

Note the following:
<ul>
<li>When the get() method returns a single object, the cardinality
of the attribute or reference is single-valued. (For example, see
the getName(), getEmployeeOfTheMonth(), and getParent() methods.)
This means that code generation will generate both get() and set()
methods for these features.</li>
<li>When the get() method returns a EList, the cardinality of the
attribute or reference is multi-valued. (For example, see the
getDepartment() and getSubsidiary() methods). This means that no
set() method will be generated. Note that the type attribute on the
@model tag is required in this case to indicate the type of object
that is contained in the EList.</li>
<li>The opposite attribute on the @model tag identifies the
opposite end of a relationship that is navigable in both
directions. (For example, the getDepartment() method specifies an
opposite attribute while the getEmployeeOfTheMonth() method does
not.) The opposite attribute is needed so that the generated code
for the implementation of the method will ensure that when one end
of a relationship is modified, the other end will be updated
accordingly.</li>
<li>When the resolveProxies attribute on the @model tag is set to
"false", (see the getEmployeeOfTheMonth() method), the generated
implementation of the get() method will assume that the target
object is never a proxy, and therefore will not attempt to resolve
the target. This improves the performance of the get() method, but
it should only be used if you are sure that the target of the
reference will never be stored in a different document from the
source.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1059" name="s1059"><h2>2.23 Java Specification for the Department
Class</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The Java interface that defines the Department class from the
Enterprise model is:
<pre>
   package org.eclipse.emf.samples.enterprise;
   import org.eclipse.emf.common.util.EList;
   import org.eclipse.emf.ecore.<tt class="code">EObject</tt>;
   /**
     @model
   */
   public interface Department extends <tt class="code">EObject</tt>{
   /**
     @model
   */
   int getNumber();
   /**
     @model opposite="department"
   */
   Company getCompany();
   /**
     @model type="Employee" opposite="department" containment="true"
   */
   EList getEmployee();
   } // Department
</pre>

 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1060" name="s1060"><h2>2.24 Java Specification for the Person
Class</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The Java interface that defines the Person class from the
Enterprise model is:
<pre>
   package org.eclipse.emf.samples.enterprise;
   import org.eclipse.emf.common.util.EList;
   import org.eclipse.emf.ecore.<tt class="code">EObject</tt>;
   /**
     @model abstract="true"
   */
   public interface Person extends <tt class="code">EObject</tt>{
   /**
     @model type="String"
   */
   EList getComments();
   /**
     @model
   */
   String getName();
   } // Person
</pre>

Note the following:
<ul>
<li>The abstract="true" attribute on the @model tag will cause code
generation to add the abstract keyword to the generated
implemenation class.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1061" name="s1061"><h2>2.25 Java Specification for the Employee
Class</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The Java interface that defines the Employee class from the
Enterprise model is:
<pre>
   package org.eclipse.emf.samples.enterprise;
   /**
     @model
   */
   public interface Employee extends Person{
      /**
        @model default="false"
      */
      boolean isManager();
      /**
        @model
      */
      String getEmail();
      /**
        @model default="FullTime"
      */
      EmploymentType getEmploymentType();
      /**
        @model dataType="enterprise.Date"
      */
      Date getDateOfHire();
      /**
        @model transient="true" changable="false" volatile="true"
      */
      int getYearsOfService();
      /**
        @model unsettable="true" dataType="enterprise.Date"
      */
      Date getLeaveOfAbsenceStart();
      /**
        @model opposite="employee"
      */
      Department getDepartment();
      /**
       @model parameters="org.eclipse.emf.samples.enterprise.Date"
      */

      void initiateLeave(Date startDate);
   } // Employee
</pre>

Note the following: 

<ul>
<li>The extends Person specification on this interface will mean
that the EmployeeImpl class will extend the PersonImpl class.</li>
<li>The changable="false" attribute on the @model tag (see
getYearsOfService()) will mean that no set() method will be
generated for the attributes and references to which it
applies.</li>
<li>The volatile="true" attribute on the @model tag (see
getYearsOfService()) will mean that no storage will be reserved for
the attributes and references to which it applies and also that the
generated implementations for the get() and set() methods will
throw an UnsupportedOperationException.</li>
<li>The transient="true" attribute on the @model tag (see
getYearsOfService()) will mean that the attributes and references
to which it applies will not be serialized.</li>
<li>The default attribute on the @model tag (see isManager() and
getEmploymentType()) provide the initial value that the attribute
will have if it has not been explicitly set.</li>
<li>The unsettable="true" attribute on the @model tag (see
getLeaveOfAbsenceStart()) will mean that the generated interface
will include unset() and isSet() methods for the attribute to which
it applies. (The use of unsettable="true" incurs some runtime
overhead due to the fact that the implementation for this will
require an additional field to remember whether or not the
attribute has been set.)</li>
<li>The initiateLeave(Date startDate) will be treated as an
operation. The generated EmployeeImpl class will include a stub
implementation of this method.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1062" name="s1062"><h2>2.26 Java Specification for the EmploymentType
Enumeration</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 An enumeration in your model is specified as a public final class
that extends org.eclipse.emf.common.util.AbstractEnumerator. You
need to identify the names and values of the enumeration literals
and EMF code generation will automatically fill in the
implementation details. For example, the Java class that defines
the EmploymentType enumeration from the Enterprise model is:
<pre>
package org.eclipse.emf.samples.enterprise;
import org.eclipse.emf.common.util.AbstractEnumerator;
/**
  @model
*/
public final class EmploymentType extends AbstractEnumerator
{
   /**
     @model name="FullTime"
   */
   public static final int FULL_TIME = 0;
   /**
     @model name="PartTime"
   */
   public static final int PART_TIME = 1;
   /**
     @model name="OnLeave"
   */
   public static final int ON_LEAVE = 2;
   private EmploymentType( int value, String name)
   {
      super (value, name);
   }
} //EmploymentType
</pre>

Note the following:
<ul>
<li>Each public static final int field defines an enumeration
literal. The initial values for each field should be unique.</li>
<li>The name of each literal is given by the name attribute on the
@model tag.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1019" name="s1019"><h2>2.27 Generating your model</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The steps for invoking the EMF code generation utility are
described in the document called "Tutorial: Generating an EMF
Model", which can be found in the "Documents" section of the EMF
web site. Please see <a class="" target="new"
href="http://www.eclipse.org/emf/">http://www.eclipse.org/emf/</a>
for details.<br />
<br />
 Configuring your EMF Runtime Environment
</p>
<p>
 There is some setup that may be needed before you can start
working with EMF objects.
</p>
<p>
 In some cases there are three alternative mechanisms you can use
to do the necessary setup. The choice of which mechanism to use
will depend on whether or not your application runs from within the
Eclipse workbench and whether the applicable configuration option
applies globally or locally.
</p>
<p>
 If your application runs as a plugin within the workbench, you can
use your plugin.xml file to specify many of the configuration
options you need. Otherwise, you will need to invoke APIs that
initialize and register the prerequisite objects. The specific API
that you need to use will depend on whether the customization is
meant to apply globally or locally.
</p>
<p>
 The following sections list the setup actions that you may need to
take. Where appropriate, each section describes the alternative
setup mechanisms for specifying each customization.
<ul>
<li>If you are using a generated package, you will need to make
sure the package is either initialized or registered before you
begin. See <a class=""
href="#s1021">Registering/Initializing a Package</a>.</li>
<li>At runtime, the contents of a generated package are accessed
through a singleton instance of a generated Package class and
instances of classes in the package are created using a singleton
instance of a generated Factory class. Your application may need to
establish a reference to one or both of these singleton objects.
See <a class="" href="#s1025">Accessing the Package and
Factory classes</a>.</li>
<li>A <tt class="code">Resource</tt> corresponds to a
collection of objects that are serialized in a single persistent
stream. If you are creating new objects or loading objects from an
existing stream, you will need to know how to create a <tt class="code">Resource</tt>. See <a class=""
href="#s1024">Creating a <tt class="code">Resource</tt></a>.</li>
<li>A <tt class="code">ResourceSet</tt> is a collection of
<tt class="code">Resource</tt> objects. You will need a
<tt class="code">ResourceSet</tt> if you have <tt class="code">Resource</tt> s that have cross references or
have common customizations. See <a class=""
href="#s1023">Creating a <tt class="code">ResourceSet</tt></a>.</li>
<li>A <tt class="code">Resource.Factory</tt> is used by the
EMF runtime to create a new <tt class="code">Resource</tt>
whenever one is needed. If you need to provide your own
implementation of the <tt class="code">Resource</tt>
interface (e.g., if you want to serialize in a format other than
XMI) then you will also have to implement and register a <tt class="code">Resource.Factory</tt> to instantiate your <tt class="code">Resource</tt> class. See <a class=""
href="#s1022">Registering a <tt class="code">Resource.Factory</tt></a>.</li>
<li>A <tt class="code">URIConverter</tt> is a class that
determines how a relative URI is resolved to an absolute URI. If
you need to override the default processing, you will need to
implement and register your own implementation of the <tt class="code">URIConverter</tt> interface. See <a
class="" href="#s1063">Registering a <tt class="code">URIConverter</tt></a>.</li>
<li>Adapter objects handle events that are triggered by a Notifier.
One possible mechanism for establishing the association between
Adapter objects and Notifier objects is to attach an <tt class="code">AdapterFactory</tt> to a <tt class="code">ResourceSet</tt>. See <a class=""
href="#s1064">Registering an <tt class="code">AdapterFactory</tt></a>.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1021" name="s1021"><b
class="section2">2.28 Registering/Initializing a
Package</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 For generated packages, before you can access the classes of a
package, you need to ensure that the package has been registered
and initialized. If you are running within the EMF workbench, you
can See Registering and Initializing a Generated Package in a
Plugin. register packages through the plugin.xml file. (See <a
class="" href="#s1065">Registering and Initializing a
Generated Package in a Plugin</a>.)
</p>
<p>
 Otherwise, you need to explicitly invoke a method that will
initialize the package. (See <a class=""
href="#s1066">Registering and Initializing a Generated Package
Using APIs</a>.)
</p>
<p>
 For dynamic packages, i.e., packages that are created by your
application at runtime, your application is responsible for the
initialization and registration of the package. (See <a
class="" href="#s1067">Registering a Dynamic
Package</a>.)
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1065" name="s1065"><h2>2.29 Registering and Initializing a Generated
Package in a Plugin</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 To preregister a package or packages, you would include the
org.eclipse.emf.ecore.generated_package extension point in your
plugin.xml file. For example, assume that you generated the
Enterprise package into a Java package called
"org.eclipse.emf.samples.enterpise". Your plugin may contain the
following extension point element: 

<pre>
   &lt;extension point="org.eclipse.emf.ecore.generated_package"&gt;
   &lt;package uri = "enterpise.xmi"
   class = "org.eclipse.emf.samples.enterpise.EnterprisePackage"/&gt;
   &lt;/extension&gt;
</pre>

 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1066" name="s1066"><h2>2.30 Registering and Initializing a Generated
Package Using APIs</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 If you are running outside of the workbench, you will need to
explicitly initialize each package that you require. You do this by
invoking the static init() method that is defined on each package
implementation. For example, a method to initialize the
EnterprisePackage would look like this:
<pre>
   protected void initializeEnterprisePackage() {

   EnterprisePackageImpl.init();

   }
</pre>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1067" name="s1067"><h2>2.31 Registering a Dynamic Package</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 If you have a dynamic package (i.e., a package that is created by
your application at runtime rather than being generated) you will
need to ensure that your package is correctly registered.
</p>
<p>
 After you create your package you must ensure that it is
registered. One way to do this is using the following method:
<pre>
   public static void registerDynamicPackage(String uri, <tt class="code">EPackage</tt> pkg)
   {
   <tt class="code">EPackage</tt>.Registry.INSTANCE.put(uri, pkg);
   }
</pre>

 Where:
<ul>
<li>uri is the string under which the package is registered</li>
<li>pkg is the package itself</li></ul>

<br />
 A dynamic package must be an instance of a class that implements
the <tt class="code">EPackage</tt> interface. Note the
default implementation of <tt class="code">EPackage</tt>,
<tt class="code">EPackageImpl</tt>, has constructors that
take a packageURI string as one of their arguments register the new
package automatically. Therefore if you use one of these
constructors to create your new package, you do not have to do
anything else to ensure that the package is registered. However, if
you use one of the other <tt class="code">EPackageImpl</tt>
constructors you need to register the package as shown above.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1025" name="s1025"><h2>2.32 Accessing the Package and Factory
classes</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 If you need to access the meta data for your package, you will
need to acquire a reference to the generated Package class.
Similarly, if you need to create instances of the classes in your
model, you will need to do so using the generated Factory class. If
you access these objects frequently, you may find it convenient to
cache the references to them. For example, a method to look up and
cache the EnterprisePackage and enterpriseFactory might look like
this:
<pre>
   EnterprisePackage EnterprisePackage=null;
   enterpriseFactory enterpriseFactory=null;
   protected void lookupPackageAndFactory() {
      Map registry = <tt class="code">EPackage</tt>.Registry.INSTANCE;
      String enterpiseURI = EnterprisePackage.eNS_URI;
      EnterprisePackage = (EnterprisePackage)registry.get(enterpiseURI);
      enterpriseFactory = EnterprisePackage.getenterpriseFactory();
   }
</pre>

 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1024" name="s1024"><b
class="section2">2.33 Creating a <tt class="code">Resource</tt></b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 A <tt class="code">Resource</tt> should be created through
either a <tt class="code">Resource.Factory</tt> or a <tt class="code">ResourceSet</tt>. (Actually, the createResource()
method on the <tt class="code">ResourceSet</tt> class is
implemented using <tt class="code">Resource.Factory</tt>, so
ultimately, every <tt class="code">Resource</tt> object is
created through a Resouce<tt class="code">.Factory</tt>.)
</p>
<p>
 <tt class="code">Resource</tt> objects may also be created
automatically. If you reference an object that is defined in a
<tt class="code">Resource</tt> that has not yet been loaded,
the <tt class="code">Resource</tt> will be automatically
loaded.
</p>
<p>
 For example, to create a <tt class="code">Resource</tt>
from a <tt class="code">ResourceSet</tt>, you could use the
following method.
<pre>
   public static <tt class="code">Resource</tt> createResourceFrom<tt class="code">ResourceSet</tt>(<tt class="code">ResourceSet</tt> resSet,
   String uri)
   {
      <tt class="code">Resource</tt> r = null;
      r = resSet.createResource(URI.createURI(uri));
      return r;
   }
</pre>

 Where:
<ul>
<li>resSet is the <tt class="code">ResourceSet</tt> that
will contain the new <tt class="code">Resource</tt></li>
<li>uri is the URI for the <tt class="code">Resource</tt> to
be serialized</li></ul>

<br />
 To create a <tt class="code">Resource</tt> from a <tt class="code">Resource.Factory</tt>, you could use the
following method. Note that if you do this, you will eventually
need to add the <tt class="code">Resource</tt> to a <tt class="code">ResourceSet</tt> explicitly.
<pre>
   public static <tt class="code">Resource</tt> createResourceFromDefaultFactory(String uri)
   {
   <tt class="code">Resource</tt> r = null;
   <tt class="code">Resource.Factory</tt> resFactory =
   <tt class="code">Resource.Factory</tt>.Registry.INSTANCE.getFactory(
      URI.createURI(uri));
      r = resFactory.createResource(URI.createURI(uri));
      return r;
   }
</pre>

 Where:
<ul>
<li>uri is the URI for in which the <tt class="code">Resource</tt> to be serialized</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1023" name="s1023"><b
class="section2">2.34 Creating a <tt class="code">ResourceSet</tt></b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 You can create a <tt class="code">ResourceSet</tt> simply
by invoking new on an implementation of the <tt class="code">ResourceSet</tt> interface. The default
implementation is in org.eclipse.emf.ecore.<tt class="code">Resource</tt>.impl.
</p>
<p>
 The create<tt class="code">ResourceSet</tt>() method
defined below provides the convenience of being able to initialize
the <tt class="code">ResourceSet</tt> with a specified <tt class="code">Resource.Factory</tt>.Registry or <tt class="code">URIConverter</tt>. If these are needed but do not
exist at the time the <tt class="code">ResourceSet</tt> is
created, they can be added later.
<pre>
   public static <tt class="code">ResourceSet</tt> create<tt class="code">ResourceSet</tt>(<tt class="code">Resource.Factory</tt>.Registry r,
   <tt class="code">URIConverter</tt> c) {
      <tt class="code">ResourceSet</tt> resSet = new <tt class="code">ResourceSetImpl</tt>();
      if (c!=null) resSet.set<tt class="code">URIConverter</tt>(c);
      if (r!=null) resSet.set<tt class="code">ResourceFactory</tt>Registry(r);
      return resSet;
   }
</pre>

Where:
</p>
<p>
 

<ul>
<li>r is the <tt class="code">Resource.Factory</tt>.Registry, if any, that will
be used by the new <tt class="code">ResourceSet</tt>.</li>
<li>c is the <tt class="code">URIConverter</tt>, if any,
that will be used by the new <tt class="code">ResourceSet</tt>.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1022" name="s1022"><b
class="section2">2.35 Registering a <tt class="code">Resource.Factory</tt></b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 You have the option of substituting your own implementation of the
<tt class="code">Resource</tt> interface for the default
implementation provided by EMF. This enables you to control the
format used to serialize your data.
</p>
<p>
 In order to specify which implementation of <tt class="code">Resource</tt> to use, you need to register a
<tt class="code">Resource.Factory</tt> that can create an
instance of the desired <tt class="code">Resource</tt>. The
default <tt class="code">Resource.Factory</tt> used to
create XMI streams is org.eclipse.emf.ecore.xmi.<tt class="code">XMIResourceFactoryImpl</tt>.
</p>
<p>
 You can register a <tt class="code">Resource.Factory</tt>
by either protocol or file extension. Once a <tt class="code">Resource.Factory</tt> is registered, anytime a
<tt class="code">Resource</tt> is generated, if the URI
matches one of the registered protocols or extensions, the
specified <tt class="code">Resource.Factory</tt> will be
used. As a special case, "*" can be used as a wild card to register
an extension <tt class="code">Resource.Factory</tt> as
applying to all extensions. (Protocols take precedence, so if a URI
matches both a registered protocol and a registered extension, the
protocol will be used. Specific extensions take precedence over the
wild card.)
</p>
<p>
 The <tt class="code">Resource.Factory</tt> that you
register can be any type that implements the
org.eclipse.emf.ecore.<tt class="code">resource</tt>.<tt class="code">Resource.Factory</tt> interface. So, for example,
if you want to save your documents in a format other than XMI, you
would implement a <tt class="code">Resource</tt> that loads
and saves the format you choose and then you would implement and
register a <tt class="code">Resource.Factory</tt> that
creates an instance of your <tt class="code">Resource</tt>
implementation.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s" name="s"><b class="section2">2.36
Registering a <tt class="code">Resource.Factory</tt> for a
Plugin</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 You can use the plugin extension points "org.eclipse.emf.ecore.extension_parser" and "org.eclipse.emf.ecore.protocol_parser" to register an
implementation of a <tt class="code">Resource.Factory</tt>.
(The term "parser" is used here because the specified <tt class="code">Resource.Factory</tt> determines which type of
<tt class="code">Resource</tt> is used which in turn
determines how an InputStream will be parsed.)
</p>
<p>
 For example, if you have defined an implementation of <tt class="code">Resource.Factory</tt> called
org.eclipse.dtd.impl.DTD<tt class="code">ResourceFactoryImpl</tt> which creates a <tt class="code">Resource</tt> that can be used to parse and
serialize DTD files, and you want this to apply to any file that
has an extension of ".dtd", you could do the following:
<pre>
   &lt;extension point = "org.eclipse.emf.ecore.extension_parser"&gt;
   &lt;parser type="dtd"
   class="org.eclipse.dtd.impl.DTDResourceFactoryImpl"/&gt;
   &lt;/extension&gt;
</pre>

 On the other hand, if you want your DTDResource implementation to
be used for any URI that has a protocol of "abc", you could do the
following:
<pre>
   &lt;extension point = "org.eclipse.emf.ecore.protocol_parser"&gt;

   &lt;parser protocolName="abc"
   class="org.eclipse.dtd.impl.DTDResourceFactoryImpl"/&gt;
   &lt;/extension&gt;
</pre>

 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s" name="s"><b class="section2">2.37
Registering a <tt class="code">Resource.Factory</tt>
Globally</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The following method registers a <tt class="code">ResourceFactory</tt> in the global <tt class="code">Resource.Factory</tt>.Registry under a specified
key.
<pre>
   public static void registerGlobalResourceFactory(<tt class="code">Resource.Factory</tt> f, 
      String key, boolean isExtension)
   {
      <tt class="code">Resource.Factory</tt>.Registry reg = <tt class="code">Resource.Factory</tt>.Registry.INSTANCE;
      Map m;
      if (isExtension) m=reg.getExtensionToFactoryMap();
      else m=reg.getProtocolToFactoryMap();
      m.put(key, f);
   }
</pre>

 Where:
<ul>
<li>f is the <tt class="code">Resource.Factory</tt> to be
registered.</li>
<li>key is the String under which the factory is registered.</li>
<li>The isExtension flag indicates if the key represents an
extension (true) or protocol (false)</li></ul>

<br />
 Registering a <tt class="code">Resource.Factory</tt>
locally
</p>
<p>
 The following method registers a <tt class="code">ResourceFactory</tt> in the local <tt class="code">Resource.Factory</tt>.Registry for a given <tt class="code">ResourceSet</tt> under a specified key.
<pre>
   public static void registerLocal<tt class="code">ResourceFactory</tt>(
      <tt class="code">ResourceSet</tt> resSet,
      <tt class="code">Resource.Factory</tt> f,
      String key,
      boolean isExtension)
   {
      <tt class="code">Resource.Factory</tt>.Registry reg = resSet.get<span
 class="javaObj">ResourceFactory</span>Registry();
      if (reg==null) {
         reg = new <tt class="code">ResourceFactory</tt>RegistryImpl();
         resSet.set<tt class="code">ResourceFactory</tt>Registry(reg);
      }
      Map m;
      if (isExtension) m=reg.getExtensionToFactoryMap();
      else m=reg.getProtocolToFactoryMap();
      m.put(key, f);
   }
</pre>

 Where:
<ul>
<li>resSet is the <tt class="code">ResourceSet</tt> that
defines the context for which the registration is in effect.</li>
<li>f is the <tt class="code">Resource.Factory</tt> to be
registered.</li>
<li>key is the String under which the factory is registered.</li>
<li>The isExtension flag indicates if the key represents an
extension ( true ) or protocol ( false )</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1063" name="s1063"><b
class="section2">2.38 Registering a <tt class="code">URIConverter</tt></b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 If you need a customized <tt class="code">URIConverter</tt>
you will need to define the implementation, create an instance of
the implementation, and then attach it to a <tt class="code">ResourceSet</tt>. There is no mechanism for
registering a <tt class="code">URIConverter</tt> for a
plugin.
<pre>
   public static void set<tt class="code">URIConverter</tt>(<tt class="code">ResourceSet</tt> resSet, <tt class="code">URIConverter</tt> c) {
   if (c!=null) resSet.set<tt class="code">URIConverter</tt>(c);
   return;
   }
</pre>

 Where:
</p>
<p>
 

<ul>
<li>resSet is the <tt class="code">ResourceSet</tt>.</li>
<li>c is the <tt class="code">URIConverter</tt>, that will
be used by the <tt class="code">ResourceSet</tt>.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1064" name="s1064"><b
class="section2">2.39 Registering an <tt class="code">AdapterFactory</tt></b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 An <tt class="code">AdapterFactory</tt> is used to create
Adapter objects and associate them with Notifier objects. You need
to register one or more <tt class="code">AdapterFactory</tt>
objects with a <tt class="code">ResourceSet</tt>.
<pre>
   public static void set<tt class="code">URIConverter</tt>(<tt class="code">ResourceSet</tt> resSet, <tt class="code">AdapterFactory</tt> af) {
   if (af!=null) resSet.getAdapterFactories().add(af);
   return;
   }
</pre>

 Where:
</p>
<p>
 

<ul>
<li>resSet is the <tt class="code">ResourceSet</tt>.</li>
<li>af is the <tt class="code">AdapterFactory</tt>, that
will be added to the <tt class="code">ResourceSet</tt>.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1026" name="s1026"><h2>2.40 Running your application</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1027" name="s1027"><h2>2.41 Creating Instance Data</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The following method illustrate the construction of two resources
that contain instances of classes that are defined in the
enterprise model.
</p>

<pre>
/**
   * createInstances
   *
   * Creates two resources that contain instances of classes from the
   * enterprise package and adds the resources to the specified <span
 class="javaObj">Resource</span> set.
   *
   */
   static void createInstances(<tt class="code">ResourceSet</tt> resSet) {
      // Access the factory (needed to create instances)
      Map registry = <tt class="code">EPackage</tt>.Registry.INSTANCE;
      String enterpriseURI = EnterprisePackage.eNS_URI;
      EnterprisePackage EnterprisePackage =
      (EnterprisePackage) registry.get(enterpriseURI);
      Enterpris<tt class="code">EFactory</tt> enterpris<tt class="code">EFactory</tt> =
      EnterprisePackage.getEnterpris<tt class="code">EFactory</tt>();
      
      // Create the resources
      <tt class="code">Resource</tt> res1 =
      resSet.createResource(URI.createURI("megacorp.enterprise"));
      <tt class="code">Resource</tt> res2 =
      resSet.createResource(URI.createURI("acme.enterprise"));
      
      // Create the first company and add it to a <tt class="code">Resource</tt>

      Company c1 = enterpris<tt class="code">EFactory</tt>.createCompany();
      c1.setName("Mega Corp");
      Department d1 = enterpris<tt class="code">EFactory</tt>.createDepartment();
      d1.setNumber(99);
      Employee e1 = enterpris<tt class="code">EFactory</tt>.createEmployee();
      e1.setName("Jane Doe");
      
      c1.getDepartment().add(d1);
      d1.getEmployee().add(e1);
      res1.getContents().add(c1);
      
      // Create the second company and add it to a <tt class="code">Resource</tt>
      Company c2 = enterpris<tt class="code">EFactory</tt>.createCompany();
      c2.setName("ACME");
      Department d2 = enterpris<tt class="code">EFactory</tt>.createDepartment();
      d2.setNumber(101);
      Employee e2 = enterpris<tt class="code">EFactory</tt>.createEmployee();
      e2.setName("John Smith");
      
      c2.getDepartment().add(d2);
      d2.getEmployee().add(e2);
      res2.getContents().add(c2);
      c1.getSubsidiary().add(c2);

   }
</pre>

 This code performs the following tasks:
<ul>
<li>Accesses the factory for the enterprise package. This involves
first going to the <tt class="code">EPackage</tt>.Registry
to find the package that is registered under the URI that is
assigned to the enterprise package and then using the package to
access the factory.</li>
<li>Creates two resources.</li>
<li>Creates the objects that are in the resources and links them
together.</li></ul>

<p>
 Note that the only objects that are added directly to the
resources are the instances of the Company class. The other classes
are connected to the Company class through containment
relationships, and therefore they should not be added to the
resources.
</p>
<p>
 The XMI documents that contain the contents of the resources are
displayed in the following section (Serializing Your Instance Data).
<p>
 Serializing Your Instance Data
</p>
<p>
 The following method illustrate how the resources that were
constructed in See <a class="" href="#s1027">Creating
Instance Data</a>. can be serialized into XMI files.
<pre>
   /**
   Creates and initializes the resrouce set and then saves the
   resources contained in that <tt class="code">Resource</tt> set.
   */
   public static void createAndSave() {
      // Initialize the enterprise package
      EnterprisePackageImpl.init();
      
      // Register the XMI <tt class="code">Resource</tt> factory for the.enterprise extension
      <tt class="code">Resource.Factory</tt>.Registry reg = <tt class="code">Resource.Factory</tt>.Registry.INSTANCE;
      Map m = reg.getExtensionToFactoryMap();
      m.put("enterprise", new <tt class="code">XMIResourceFactoryImpl</tt>());
      
      // Obtain a new <tt class="code">Resource</tt> set
      <tt class="code">ResourceSet</tt> resSet = new <tt class="code">ResourceSetImpl</tt>();
      
      // Create resources and instances; add the resources to the <span
 class="javaObj">Resource</span> set
      createInstances(resSet);
      
      // Save each <tt class="code">Resource</tt>

      Iterator r = resSet.getResources().iterator();
      while (r.hasNext()) {
         <tt class="code">Resource</tt> res = (<tt class="code">Resource</tt>) r.next();
         Map options = new HashMap();
         options.put(<tt class="code">XMIResource</tt>.OPTION_DECLARE_XML, Boolean.TRUE);
         try {
            res.save(options);
         } catch (IOException e) {
            System.out.println(e);
         }
      }
   }
</pre>

This code performs the following tasks:
<ul>
<li>Initializes the enterprise package, which causes the package to
be registered so that it can later be looked up by its URI.</li>
<li>Registers the XMI <tt class="code">Resource</tt> factory
for the.enterprise extension.This will cause all documents with
this extension to be treated as XMI documents.</li>
<li>Obtains a <tt class="code">Resource</tt> set.</li>
<li>Creates resources and instances using the method define in See
<a class="" href="#s1027">Creating Instance Data</a>. .
This method will add all the resources it creates into the
specified <tt class="code">Resource</tt> set.</li>
<li>Saves the resources.</li></ul>

<br />
 The result of the createIstances method is to produce two
resources called megacorp.enterprise and acme.enterprise, which
each contain one instance of a Company, a Department, and an
Employee.
</p>
<p>
 The contents of the megacorp.enterprise <tt class="code">Resource</tt> is:
<pre>
   &lt;?xml version="1.0" encoding="ASCII"?&gt;

   &lt;enterprise:Company xmi:version="2.0" xmlns:xmi="<a
class="" target="new"
href="http://www.omg.org/XMI">http://www.omg.org/XMI</a>" 
      xmlns:enterprise="enterprise.xmi" name="Mega Corp"&gt;
   &lt;department number="99"&gt;
   &lt;employee name="Jane Doe"/&gt;
   &lt;/department&gt;
   &lt;subsidiary href="acme.enterprise#/"/&gt;

   &lt;/enterprise:Company&gt;
   &lt;?xml version="1.0" encoding="ASCII"?&gt;
</pre>

 And the contents of the acme.enterprise <tt class="code">Resource</tt> is:
<pre>
   &lt;enterprise:Company xmi:version="2.0" xmlns:xmi="<a
class="" target="new"
href="http://www.omg.org/XMI">http://www.omg.org/XMI</a>" 
      xmlns:enterprise="enterprise.xmi" name="ACME"&gt;

   &lt;department number="101"&gt;
   &lt;employee name="John Smith"/&gt;
   &lt;/department&gt;
   &lt;parent href="megacorp.enterprise#/"/&gt;
   &lt;/enterprise:Company&gt;
</pre>

 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1029" name="s1029"><h2>2.42 Loading Instance Data</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The following method illustrates how the XMI files that were
generated in the example in See <a class=""
href="#s1028">Serializing Your Instance Data</a>. can be loaded
back into memory.
<pre>
   /**
   * load
   *
   * loads and prints the contents of a <tt class="code">Resource</tt> set
   *
   */
   public static void load() {
      // Initialize the enterprise package
      EnterprisePackageImpl.init();

      // Register the XMI <tt class="code">Resource</tt> factory for the.enterprise extension
      <tt class="code">Resource.Factory</tt>.Registry reg = <tt class="code">Resource.Factory</tt>.Registry.INSTANCE;
      Map m = reg.getExtensionToFactoryMap();
      m.put("enterprise", new <tt class="code">XMIResourceFactoryImpl</tt>());

      // Obtain a new <tt class="code">Resource</tt> set
      <tt class="code">ResourceSet</tt> resSet=new <tt class="code">ResourceSetImpl</tt>();

      // Load one of the resources into the resoruce set.
      <tt class="code">Resource</tt> res = resSet.getResource(
      URI.createURI("megacorp.enterprise"),true);

      // Print all the resources inthe <tt class="code">Resource</tt> set.
      // Note: the process of printing the contents of the first <span
 class="javaObj">Resource</span>

      // will cause the second <tt class="code">Resource</tt> to be demand loaded.
      List resList = resSet.getResources();
      for (int i=0; i&lt;resList.size(); i++) {
      res = (<tt class="code">Resource</tt>) resList.get(i);
      System.out.println("\n-----------------------------------------");
      System.out.println("\nContents of <tt class="code">Resource</tt> "+res.getURI());
      System.out.println("\n-----------------------------------------\n");
      UGRefPrint.print(res.getContents());
      }
   }
</pre>

 This code performs the following tasks:
</p>
<p>
 

<ul>
<li>Initializes the enterprise package, which causes the package to
be registered so that it can later be looked up by its URI.</li>
<li>Registers the XMI <tt class="code">Resource</tt> factory
for the.enterprise extension.This will cause all documents with
this extension to be treated as XMI documents.</li>
<li>Obtains a <tt class="code">Resource</tt> set.</li>
<li>Loads one of the resources explicitly.</li>
<li>Prints out both of the resources using the print utility that
is described in See <a class="" href="#s1033">Using
Reflective APIs</a>.</li></ul>

<br />
 The output of this method is shown below. Note that only
megacorp.enterprise <tt class="code">Resource</tt> is
explicitly loaded by this code, but the output includes both
megacorp.enterprise and acme.enterprise. The megacorp.enterprise
<tt class="code">Resource</tt> includes a reference to an
object in the acme.enterprise document. Therefore, the process of
printing out megacorp.enterprise forces acme.enterprise to be
demand loaded. In the above code above, resList initially contains
one <tt class="code">Resource</tt>, but during the call to
UGRefPrint.print, the second <tt class="code">Resource</tt>
is added to this list.
<pre>
   -----------------------------------------
   Contents of <tt class="code">Resource</tt> megacorp.enterprise
   -----------------------------------------
   
   Company:
   name: Mega Corp
   department:
   number: 99
   company:
   name: Mega Corp
   employee:
   name: Jane Doe
   department:
   number: 99
   subsidiary:
   name: ACME
   
   -----------------------------------------
   Contents of <tt class="code">Resource</tt> acme.enterprise
   -----------------------------------------
   
   Company:
   name: ACME
   department:
   number: 101
   company:
   name: ACME
   employee:
   name: John Smith
   department:
   number: 101
   parent:
   name: Mega Corp
</pre>

 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1030" name="s1030"><h2>2.43 Handling notifications</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1033" name="s1033"><h2>2.44 Using Reflective APIs</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 EMF provides APIs that enable you to access your data
reflectively. This means that you can view and manipulate EMF data
without having any prior knowledge of the model. (See Examining
<tt class="code">EObject</tt> Instances using
Reflection<br />
<br />
 and Modifying <tt class="code">EObject</tt>s using
reflection.) Also, you can dynamically create new classes or extend
classes that have been generated.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1034" name="s1034"><b
class="section2">2.45 Examining <tt class="code">EObject</tt> Instances using
Reflection</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The methods described in this section can be used to print out the
contents of an <tt class="code">EObject</tt> without having
any prior knowledge of the structure of that <tt class="code">EObject</tt>. The methods defined here are all
static and are assumed to be in the same class.
</p>
<p>
 The only public method in this class is print, which takes a
collection of <tt class="code">EObject</tt> objects and
displays the contents of the objects in System.out.
</p>
<p>
 The See print. method invokes See printObject. to display each
object in the Collection. The printObject() method prints the name
of the object and then displays the contents of the object by
invoking See printAllAttributes. and See <a class=""
href="#s1068">printAllReferences</a>.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s" name="s"><h2>2.46 print</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The print method invokes See <a class=""
href="#s1069">printObject</a>. to display each object in the
Collection. This can be any Collection that contains <tt class="code">EObject</tt> objects. For example, it might be
the contents of a <tt class="code">Resource</tt>.
<pre>
   static public void print(Collection list) {

      Iterator iter = list.iterator();
      while (iter.hasNext()) {
      Object object = iter.next();
      if (object instanceof <tt class="code">EObject</tt>)
         See <a class=""
href="#s1069">printObject</a>.  (0, (<tt class="code">EObject</tt>)object, null, true);
      }
   }
</pre>

 Where:
</p>
<p>
 

<ul>
<li>list is the collection of <tt class="code">EObject</tt>
instances to be printed. (For example, this could be the collection
returned by the getContents() method of a <tt class="code">Resource</tt> object.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1069" name="s1069"><h2>2.47 printObject</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The printObject() method can be called either on a root object or
it can be called to display the target of a reference. When a root
object is printed, the name for the object will be the name of the
object's class. When a reference is printed, the name will be the
name of the reference.
</p>
<p>
 All the attributes of the object are displayed by calling See <a
class="" href="#s1070">printAllAttributes</a>.
</p>
<p>
 The printReferences argument that is passed to See printObject. is
a flag to indicate whether or not to display the references that
belong to the object. In the case of a root object, the references
are always displayed. For a non-root object, the references will be
displayed if the object is being printed as part of its container.
(This is needed to prevent the possibility of infinite recursion
when invoking See <a class=""
href="#s1069">printObject</a>. .)
</p>
<p>
 If the printReferences flag is true, the references are displayed
by calling printAllReferences().
<pre>
   static private void printObject(
      int tabIndex,
      <tt class="code">EObject</tt> <tt class="code">EObject</tt>,
      <tt class="code">EReference</tt> referenceObj,
      boolean printReferences) {
      if (tabIndex != 0) {
         System.out.println();
         for (int i = 0; i &lt; tabIndex; i++)
            System.out.print("\t");
      }
      ENamedElement nameObj =
         (referenceObj == null)
         ? (ENamedElement) <tt class="code">EObject</tt>.<tt class="code">EClass</tt>()
         : referenceObj;
      System.out.println(nameObj.getName() + ": " );
      
      See <a class=""
href="#s1070">printAllAttributes</a>.  (tabIndex + 1, <tt class="code">EObject</tt>);      
      if (printReferences)
         See <a class=""
href="#s1068">printAllReferences</a>.  (tabIndex, <tt class="code">EObject</tt>);
   }
</pre>

 Where:
</p>
<p>
 

<ul>
<li>tabIndex is an integer that controls the indentation of the
output line</li>
<li><tt class="code">EObject</tt> is the object to be
printed.</li>
<li>referenceObj is the <tt class="code">EReference</tt>
that was traversed to access <tt class="code">EObject</tt>.
If referenceObj is null, the <tt class="code">EObject</tt>
is a root object.</li>
<li>The printReferences flag indicates whether the output for the
<tt class="code">EObject</tt> should include the objects
that the <tt class="code">EObject</tt> references. (The
references are only printed for containments.)</li></ul>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1070" name="s1070"><h2>2.48 printAllAttributes</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The printAllAttributes() method first accesses the meta object for
a given object and then accesses and traverses the list of
attributes that belong to the meta object. The printAttribute()
method is invoked for each attribute to print out the appropriate
value, if it exists.
<pre>
   static private void printAllAttributes(int tabIndex, <tt class="code">EObject</tt> <tt class="code">EObject</tt>) {
      <tt class="code">EClass</tt> eMetaObject = <tt class="code">EObject</tt>.<tt class="code">EClass</tt>();
      if (eMetaObject == null)
         return;
      
      Collection attrs = eMetaObject.getEAllAttributes();
      if (attrs == null)
         return;
      Iterator iAttr = attrs.iterator();
      
      while (iAttr.hasNext()) {
         <tt class="code">EAttribute</tt> eAttr = (<tt class="code">EAttribute</tt>) iAttr.next();
         See <a class=""
href="#s1071">printAttribute</a>.  (tabIndex, <tt class="code">EObject</tt>, eAttr);
      }
   }
</pre>

 Where:
</p>
<p>
 

<ul>
<li>tabIndex is an integer that controls the indentation of the
output line</li>
<li><tt class="code">EObject</tt> is the object to be
printed.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1071" name="s1071"><h2>2.49 printAttribute</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The printAttribute() method displays the value for a single
attribute, if it exists. The value of the attribute is obtained by
calling the reflective method E Object.eGet(<tt class="code">EStructuralFeature</tt>). Note that if the
attribute is a single-valued attribute, the value will be a single
Object. Otherwise it will be a Collection of objects.
<pre>
   static private void printAttribute(
      int tabIndex,
      <tt class="code">EObject</tt> <tt class="code">EObject</tt>,
      <tt class="code">EAttribute</tt> eAttr) {
      if (!<tt class="code">EObject</tt>.eIsSet(eAttr)) {
         return;
      }
      
      Object value = <tt class="code">EObject</tt>.eGet(eAttr);
      
      if (eAttr.isVolatile() || (value == null))
         return;
      
      String valueS = "";
      if (eAttr.isMany()) {
         Iterator vals = ((Collection) value).iterator();
         while (vals.hasNext()) {
            if (valueS.length() &gt; 0)
            valueS += ", ";
            valueS += vals.next().toString();
         }
      }
      else
      valueS = value.toString();
      for (int i = 0; i &lt; tabIndex; i++)
        System.out.print("\t");
      
      System.out.println(eAttr.getName() + ": " + valueS);
      return;
   }
  
</pre>

 Where:
</p>
<p>
 

<ul>
<li>tabIndex is an integer that controls the indentation of the
output line</li>
<li><tt class="code">EObject</tt> is the object to be
printed.</li>
<li>eAttr is the attribute to be printed.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1068" name="s1068"><h2>2.50 printAllReferences</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The printAllReferences() method first accesses the meta object for
a given object and then accesses and traverses the list of
references that belong to the meta object. The printReference()
method is invoked for each reference to print out the appropriate
object, if it exists.
<pre>
   static private void printAllReferences(int tabIndex, <tt class="code">EObject</tt> <tt class="code">EObject</tt>) {
      <tt class="code">EClass</tt> eMetaObject = <tt class="code">EObject</tt>.<tt class="code">EClass</tt>();
      if (eMetaObject == null)
         return;
      
      Collection refs = eMetaObject.getEAllReferences();
      
      if (refs == null)
         return;
      Iterator iRef = refs.iterator();
      
      while (iRef.hasNext()) {
         <tt class="code">EReference</tt> ref = (<tt class="code">EReference</tt>) iRef.next();
         See <a class=""
href="#s1072">printReference</a>.  (tabIndex, <tt class="code">EObject</tt>, ref);
      }
   }
   

</pre>

 Where:
</p>
<p>
 

<ul>
<li>tabIndex is an integer that controls the indentation of the
output line</li>
<li><tt class="code">EObject</tt> is the object to be
printed.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1072" name="s1072"><h2>2.51 printReference</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The printReference() method displays the value for a single
reference, if it exists. The value of the reference is obtained by
calling the reflective method <tt class="code">EObject</tt>.eGet(<tt class="code">EStructuralFeature</tt>). Note that if the
reference is a single-valued reference, the value will be a single
Object. Otherwise it will be a Collection of objects.
</p>
<p>
 The target of the reference is printed out by calling
printObject() recursively. Note that for containment references, we
want to print the contained object plus all of its references while
for non-containment references, we only want to print the object.
This will prevent the possibility of infinite recursion.
<pre>
   static private void printReference(
      int tabIndex,
      <tt class="code">EObject</tt> <tt class="code">EObject</tt>,
      <tt class="code">EReference</tt> ref) {
      Object value = <tt class="code">EObject</tt>.eGet(ref);
      if (ref.isVolatile() || (value == null))
         return;
      
      if (ref.isMany()) {
         Iterator vals = ((Collection) value).iterator();
         while (vals.hasNext()) {
            <tt class="code">EObject</tt> eValue = (<tt class="code">EObject</tt>)vals.next();
            if (eValue==null)
               return;
            boolean printNestedReferences =
            eValue.eContainer() == <tt class="code">EObject</tt>;
            printObject(tabIndex + 1, eValue, ref, printNestedReferences);
         }
      }
      else {
         <tt class="code">EObject</tt> eValue = (<tt class="code">EObject</tt>)value;
         boolean printNestedReferences = eValue.eContainer() == <span
 class="javaObj">EObject</span>;
         printObject(tabIndex + 1, eValue, ref, printNestedReferences);
      }
   }
</pre>

 Where:
</p>
<p>
 

<ul>
<li>tabIndex is an integer that controls the indentation of the
output line</li>
<li><tt class="code">EObject</tt> is the object to be
printed.</li>
<li>ref is the reference to be printed.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s" name="s"><b class="section2">2.52
Customizing a <tt class="code">URIConverter</tt></b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 Suppose you have special rules for resolving relative URIs. You
can implement those rules by creating your own implementation of
the org.eclipse.emf.ecore.<tt class="code">Resource</tt>.<tt class="code">URIConverter</tt> interface and attaching it to
the <tt class="code">ResourceSet</tt> that will be used to
load and save the <tt class="code">Resource</tt>.
</p>
<p>
 For example, suppose you would like all relative URIs to resolve
to a specific location on your file system. Your implementation of
<tt class="code">URIConverter</tt> could look like
this:
<pre>
   public class UG<tt class="code">URIConverterImpl</tt> extends <tt class="code">URIConverterImpl</tt>
   {
      private URI baseURI=null;
      
      /**
      * Construct a UG<tt class="code">URIConverterImpl</tt> from a specified base uri
      */
      public UG<tt class="code">URIConverterImpl</tt>(String base)
      {
         if (base!=null) baseURI=URI.createURI(base);
      }
      *
      /**
      Normalize the uri.
      &lt;p&gt;

      If the uri is relative and if the baseURI has been specified,
      simply resolve the uri against the base.
      Otherwise defer to the super classs's implementation.
      */
      public URI normalize(URI uri)
      {
         if (uri.isRelative() &amp;&amp; baseURI!=null) {
            return uri.resolve(baseURI);
         }
         return super.normalize(uri);
      }
      *
      /**
      Creates an output stream and returns it.
      &lt;p&gt;
      If the normalized uri is a file scheme, use the normalized uri to
      construct the output stream directly. Otherwise defer to the super classs's
      implementation.
      */
      public OutputStream createOutputStream(URI uri) throws IOException
      {
         URI converted = normalize(uri);
         String scheme = converted.scheme();
         if ("file".equals(scheme))
         {
            return createFileOutputStream(converted.toFileString());
         }
         return super.createOutputStream(uri);
      }
      *
      /**
      Creates an input stream and returns it.
      &lt;p&gt;
      If the normalized uri is a file scheme, use the normalized uri to
      construct the input stream directly. Otherwise defer to the super classs's
      implementation.
      */
      public InputStream createInputStream(URI uri) throws IOException
      {
         URI converted = normalize(uri);
         String scheme = converted.scheme();
         if ("file".equals(scheme))
         {
            return createFileInputStream(converted.toFileString());
         }
         return super.createInputStream(uri);
      }
   } // <tt class="code">URIConverterImpl</tt>
</pre>

 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1002" name="s1002"><h1>3 Quick Reference</h1></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The following sections provide reference information:
</p>
<p>
 

<ul>
<li>See <a class="" href="#s1056">Ecore Properties and
Codegen Specifications</a>. for an description of all the
properties that you may need to use when generating code.</li>
<li>See <a class="" href="#s1073">EMF APIs</a>. for a link
to information on using the EMF APIs.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1056" name="s1056"><h2>3.01 Ecore Properties and Codegen
Specifications</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The code patterns used by the EMF code generation utility are
determined by the properties of the packages, classes, attributes,
and relationships that you specify in your model. EMF supports
three different formats for the specification of a model, namely,
UML, XMI, and Java. Whichever format you use, you will need to be
aware of how the model properties are specified in that
format.
</p>
<p>
 The following sections enumerate all the properties that apply to
each element of an Ecore model. Each section has two tables. The
first table lists the properties and how they impact the code
generation process and the second table shows how each of these
properties is specified in each of the three formats.
</p>
<p>
 Here is an overview of the Ecore model elements:
</p>
<ul>
<li>An <tt class="code">EPackage</tt> (See <a
class="" href="#s1074"><tt class="code">EPackage</tt> Properties</a>.) is a collection of
<tt class="code">EClass</tt>ifier objects. Each package has
a package URI which is used to uniquely identify the package.</li>
<li>An <tt class="code">EClass</tt>ifier is the description
of a type in Ecore. Each <tt class="code">EClass</tt>ifier
is either an <tt class="code">EClass</tt> or an <tt class="code">EDataType</tt></li>
<li>An <tt class="code">EClass</tt> (See <a class=""
href="#s1075"><tt class="code">EClass</tt> Properties</a>.)
is a description of a fundamental Ecore data element. Every <tt class="code">EObject</tt> is an instance of an <tt class="code">EClass</tt>.<br />
 An <tt class="code">EClass</tt> may be abstract or concrete
and it may derive from other classes. It consists of zero or more
<tt class="code">EStructuralFeature</tt>s and
EOperations.</li>
<li>An <tt class="code">EDataType</tt> (See <a
class="" href="#s1076"><tt class="code">EDataType</tt> Properties</a>.) is a description
of a type whose values are not Ecore objects. This can be a
primitive type, a Java Class that is defined outside of the Ecore
model, or an <tt class="code">EEnum</tt>.</li>
<li>An <tt class="code">EEnum</tt> (See <a class=""
href="#s1077"><tt class="code">EEnum</tt> Properties</a>.)
is a type that is constructed for a specified list of
EEnumLiterals<br />
 (See <a class="" href="#s1078"><tt class="code">EEnumLiteral</tt> Properties</a>.).</li>
<li>An <tt class="code">EStructuralFeature</tt> is a
component of an <tt class="code">EClass</tt> that describe a
field that belongs to the Class. Each <tt class="code">EStructuralFeature</tt> is either an <tt class="code">EAttribute</tt> (See <a class=""
href="#s1079"><tt class="code">EAttribute</tt>
Properties</a>.) or an <tt class="code">EReference</tt><br />
 (See <a class="" href="#s1080"><tt class="code">EReference</tt> Properties</a>.).<br />
 Each <tt class="code">EAttribute</tt> or <tt class="code">EReference</tt> has a type (i.e. either an <tt class="code">EClass</tt> or an <tt class="code">EDataType</tt> ) and may also have other
properties that define its cardinality, changeability, default
value (if any), persistence, etc.</li>
<li>An <tt class="code">EOperation</tt> (See <a
class="" href="#s1081"><tt class="code">EOperation</tt> Properties</a>.) is a component
of an <tt class="code">EClass</tt> that describes a method
belonging to the class.<br />
 Each <tt class="code">EOperation</tt> has a type (which may
be an <tt class="code">EClass</tt>, an <tt class="code">EDataType</tt>, or null) and also has zero or
more EParamter objects (See <a class="" href="#s1082"><tt class="code">EParameter</tt> Properties</a>.).</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1074" name="s1074"><b
class="section2">3.02 <tt class="code">EPackage</tt>
Properties</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>

<p>
 The properties of an <b class="javaObj"><tt class="code">EPackage</tt></b> in Ecore are:
</p>

<p style="text-align: center"><a id="table1" name="table1"><span
class="jet">TABLE 1. Ecore Properties for <tt class="code">EPackage</tt></span></a></p>

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>Usage</b>
</th>
<th>
<b>Default</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>The name of the package. This name is used as the name of the
generated package Interface.</td>
<td>No default.</td>
</tr>

<tr>
<td><tt>nsURI</tt></td>
<td>The Namespace URI of the package, i.e. the URI that appears in
the xmlns tag to identify this package in an XMI document.</td>
<td>nsName with a suffix of ".xmi"</td>
</tr>

<tr>
<td><tt>nsPrefix</tt></td>
<td>The Namespace prefix that is used when references to instances
of the classes in this package are serialized.</td>
<td>The nsName with the first character converted to upper
case.</td>
</tr>

<tr>
<td><tt>eClassifiers</tt></td>
<td>The classes, enumerations and datatypes contained in the
package. (See <tt class="code">EClass</tt> Properties , See
<a class="" href="#s1083"><tt class="code">EEnum</tt> Properties , and <tt class="code">EDataType</tt> Properties</a>.)</td>
<td>empty</td>
</tr>

<tr>
<td><tt>eSubpackages</tt></td>
<td>The nested packages. This information is used to construct the
default names and namespace URIs for the subpackages. Also, a
package and its subpackages are treated as a group for the purposes
of initialization, so that when one package is initialized, all the
other packages in the group will also be initialized.</td>
<td>none</td>
</tr>

<tr>
<td><tt>prefix</tt></td>
<td>Used as the prefix for the names of the generated Factory and
Package classes.</td>
<td>Same as package name specified in the model</td>
</tr>

<tr>
<td><tt>basePackage</tt></td>
<td>The prefix used for the Java package that contains the
generated code for the model.</td>
<td>"" (i.e., the empty string)</td>
</tr>
</table>

<p>
 These properties are specified to EMF<br />
<br />
 code generation in one of the following ways:
</p>
<p>
 

<ul>
<li class="Bulleted">UML - The properties are set via a package
object in a UML diagram or via the specification dialog box for the
package. (See See <a class="" href="#s1045">Ecore
Properties for Packages</a>. for anexample.)</li>

<li class="Bulleted">XMI - Most of these properties are specified
as attributes or sub-elements of the <tt>ecore:EPackage</tt> element in the ecore document.
The <tt>ecore:EPackage</tt> document is typically the
root of the document. (See See The Enterprise Package Element in
the Ecore Document. for an example.) Some of the package properties
are specified in the genPackage element of the genmodel document
(See See Genmodel Document for the enterprise Model. for an
example.)</li>

<li class="Bulleted">Java - The properties are implicitly derived
from the java package that contains the various <tt>interface</tt> declarations that define the classes
in your model. Alternatively, you can specify an explicit <tt>interface</tt> statement for a package or from the
<tt>@model</tt> tag that precedes the <tt>interface</tt> statement. You could do this if you
want to override some of the properties of the package. However,
you may find that the easiest way to do this is to allow the code
generation utility to automatically create the initial version of
this <tt>interface</tt> statement, after which you
can make the modifications you require. (See See Java Specification
for the Enterprise Package. for an example.)</li>
</ul>

<br />
 

<p style="text-align: center"><a id="table2" name="table2"><span
class="jet">TABLE 2. Codegen Specifications for <tt class="code">EPackage</tt> Properties</span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>UML</b>
</th>
<th>
<b>XMI</b>
</th>
<th>
<b>Java</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>name of the package in the UML diagram or the <tt>packageName</tt> property is specified on the eCore
page of the specification dialog for the UML Package.</td>
<td><tt>name</tt> attribute<sup><a href="#fn2"
class="footnote">2</a></sup></td>
<td>Implicitly derived from the Java package<sup><a href="#fn3"
class="footnote">3</a></sup> .</td>
</tr>

<tr>
<td><tt>nsURI</tt></td>
<td><tt>nsURI</tt> property<sup><a href="#fn4"
class="footnote">4</a></sup></td>
<td><tt>nsURI</tt> attribute on the ecore:Package
element in the ecore document.</td>
<td>The initial value of the <tt>eNSURI</tt>
field<sup><a href="#fn5" class="footnote">5</a></sup></td>
</tr>

<tr>
<td><tt>nsPrefix</tt></td>
<td><tt>prefix</tt> property is specified on the
eCore page of the specification dialog for the UML Package.</td>
<td><tt>nsPrefix</tt> attribute on the ecore:Package
element in the ecore document.</td>
<td>The initial value of the <tt>eNSPrefix</tt> field is
a member of the interface that corresponds to the package
itself.</td>
</tr>

<tr>
<td><tt>eClassifiers</tt></td>
<td>The classes, enumerations, and datatypes that are contained in
the UML Package</td>
<td><tt>eClassifiers</tt> element on the
ecore:Package element in the ecore document.</td>
<td>Derived from the interfaces, classes and datatypes within this
Java package is the Java package that is specified on the package
statement of the interfaces and/or classes contained in the
package.</td>
</tr>

<tr>
<td><tt>eSubpackages</tt></td>
<td>Nested packages is specified on the eCore page of the
specification dialog for the UML Package.</td>
<td><tt>eSubpackages</tt> element on the
ecore:Package element in the ecore document.</td>
<td>n/a<sup><a href="#fn6" class="footnote">6</a></sup></td>
</tr>

<tr>
<td><tt>prefix</tt></td>
<td><tt>prefix</tt> property is specified on the
eCore page of the specification dialog for the UML Package.</td>
<td><tt>prefix</tt> attribute<sup><a href="#fn7"
class="footnote">7</a></sup></td>
<td>The prefix part of the name of the Java package is the Java
package that is specified on the package statement of the
interfaces and/or classes contained in the package.</td>
</tr>

<tr>
<td><tt>basePackage</tt></td>
<td><tt>basePackage</tt> property is specified on the
eCore page of the specification dialog for the UML Package.</td>
<td><tt>basePackage</tt> attribute on the subPackages
element in the genmodel document.</td>
<td>The base part of the Java package. This is the Java package
that is specified on the package statement of the interfaces and/or
classes contained in the package.</td>
</tr>
</table>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1075" name="s1075"><b
class="section2">3.03 <tt class="code">EClass</tt>
Properties</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The properties of an <b class="javaObj"><tt class="code">EClass</tt></b> in Ecore are:
</p>

<p style="text-align: center"><a id="table3" name="table3"><span
class="jet">TABLE 3. Ecore Properties for <tt class="code">EClass</tt></span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>Usage</b>
</th>
<th>
<b>Default</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>Used to construct the names of the generated interface and
implementation class. (The name of the implementation class has a
suffix of "<tt>Impl</tt> ")</td>
<td>no default</td>
</tr>

<tr>
<td><tt>instanceClass</tt></td>
<td>Used by the EMF runtime to validate the type of objects on a
type-safe list. For non-dynamic classes, this is always the
generated interface. null indicates a dynamic class.</td>
<td>the generated interface</td>
</tr>

<tr>
<td><tt>defaultValue</tt></td>
<td>The intrinsic default value for a class. This default will be
applied to any attributes of the class. Note: this property cannot
be modified for <tt class="code">EClass</tt> objects. It's
value is always <tt>null</tt> .</td>
<td><tt>null</tt></td>
</tr>

<tr>
<td><tt>abstract</tt></td>
<td>If <tt>true</tt> , the generated implementation
class will have the <tt>abstract</tt> keyword</td>
<td><tt>false</tt></td>
</tr>

<tr>
<td><tt>interface</tt></td>
<td>If <tt>true</tt> , only the java <tt>interface</tt> will be generated. There will be no
corresponding implementation class and no create method in the
factory.</td>
<td><tt>false</tt></td>
</tr>

<tr>
<td><tt>eAttributes</tt></td>
<td>The attributes associated with the class. Used to construct the
accessor methods for the interface and implementation of the
class.<sup><a href="#fn8" class="footnote">8</a></sup> (See <a
class="" href="#s1079"><tt class="code">EAttribute</tt> Properties</a>.)</td>
<td>none</td>
</tr>

<tr>
<td><tt>eReferences</tt></td>
<td>The attributes associated with the class. Used to construct the
accessor methods for the interface and implementation of the
class.See Depending on the properties of the attribute or
reference, the accessor methods may be get(), set(), isSet() and
unset(). Usually, the implementations of these methods are
generated automatically. (See <a class=""
href="#s1080"><tt class="code">EReference</tt>
Properties</a>.)</td>
<td>none</td>
</tr>

<tr>
<td><tt>eOperations</tt></td>
<td>The attributes associated with the class. Used to construct the
additional methods that are part of the class. (Note: code
generation creates stubs for the implementations of these methods.)
(See <a class="" href="#s1081"><tt class="code">EOperation</tt> Properties</a>.)</td>
<td>none</td>
</tr>

<tr>
<td><tt>eSupertypes</tt></td>
<td>The supertypes for this class. Used to construct the <tt>extends</tt> clauses of the generated <tt>interface</tt> and <tt>class</tt>
statements. Note: the generated interface will extend from all the
interfaces for all the supertypes. However, the generated
implementation class will only extend from the implementation class
of the first supertype in the list.</td>
<td>none</td>
</tr>
</table>

<p>
 These properties are specified to EMF<br />
<br />
 code generation in one of the following ways:
</p>
<p>
 

<ul>
<li class="Bulleted">UML - The properties are set via a UML class
object or via the specification dialog box for that class. (See See
Basic UML Model Elements. for an example.)</li>

<li class="Bulleted">XMI - The properties are specified as
attributes or sub-elements of an <tt>ecore:EClass</tt> element in the XMI document. The
<tt>ecore:EClass</tt> is typically one of the <tt>eClassifiers</tt> sub-elements of the <tt>ecore:EPackage</tt> object that is at the root of
the XMI document. (See See The Company Class Element in the Ecore
Document. for an example.)</li>

<li class="Bulleted">Java - The properties are derived from the <tt>interface</tt> statement for a class or from the <tt class="code">@model</tt> tag that precedes the <tt>interface</tt> statement. (See See Java
Specification for the Company Class. for an example.)</li>
</ul>

<br />
 

<p style="text-align: center"><a id="table4" name="table4"><span
class="jet">TABLE 4. Codegen Specifications for <tt class="code">EClass</tt> Properties</span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>UML</b>
</th>
<th>
<b>XMI</b>
</th>
<th>
<b>Java</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>The name of the class in the UML diagram</td>
<td><tt>name</tt> attribute<sup><a href="#fn9"
class="footnote">9</a></sup></td>
<td>The name of the Java <tt>interface</tt> .</td>
</tr>

<tr>
<td><tt>instanceClass</tt></td>
<td>n/a<sup><a href="#fn10" class="footnote">10</a></sup></td>
<td>n/aSee You do not specify the instanceClass property
explicitly. The value is always the generated interface.</td>
<td>n/aSee You do not specify the instanceClass property
explicitly. The value is always the generated interface.</td>
</tr>

<tr>
<td><tt>defaultValue</tt></td>
<td>n/a<sup><a href="#fn11" class="footnote">11</a></sup></td>
<td>n/aSee You do not specify the default value property
explicitly. The value is always null.</td>
<td>n/aSee You do not specify the default value property
explicitly. The value is always null.</td>
</tr>

<tr>
<td><tt>abstract</tt></td>
<td>The <tt>abstract</tt> property on the UML
class<sup><a href="#fn12" class="footnote">12</a></sup> .</td>
<td><tt>abstract</tt> attribute on the eClassifiers
element that has an xsi:type of ecore:EClass in the ecore
document.</td>
<td><tt>abstract</tt> property<sup><a href="#fn13"
class="footnote">13</a></sup></td>
</tr>

<tr>
<td><tt>interface</tt></td>
<td>The <tt>&lt;&lt;interface&gt;&gt;</tt> stereotype
on the UML Class</td>
<td><tt>interface</tt> attribute on the eClassifiers
element that has an xsi:type of ecore:EClass in the ecore
document.</td>
<td><tt>interface</tt> propertySee The property is
specified via the @model tag that precedes the interface statement
for the class.</td>
</tr>

<tr>
<td><tt>attributes</tt></td>
<td>All the attributes associated the class</td>
<td><tt>attributes</tt> element on the eClassifiers
element that has an xsi:type of ecore:EClass in the ecore
document.</td>
<td>All the <tt>get()</tt> methods on the <tt>interface</tt> that have a <tt class="code">@model</tt> tag and whose return type is a primitive
type</td>
</tr>

<tr>
<td><tt>references</tt></td>
<td>All the relations associated with the class</td>
<td><tt>references</tt> element on the eClassifiers
element that has an xsi:type of ecore:EClass in the ecore
document.</td>
<td>All the <tt>get()</tt> methods on the <tt>interface</tt> that have a <tt class="code">@model</tt> tag and whose return type is an Ecore
class</td>
</tr>

<tr>
<td><tt>operations</tt></td>
<td>All the operations associated with the class</td>
<td><tt>operations</tt> element on the eClassifiers
element that has an xsi:type of ecore:EClass in the ecore
document.</td>
<td>Any method that is flagged with an <tt>@model</tt>
tag and is not the <tt>get()</tt> method for and
attribute or reference<a href="#pgfId=962900"
class="footnote">14</a> </td>
</tr>

<tr>
<td><tt>supertypes</tt></td>
<td>All the generalizations associated with the class</td>
<td><tt>supertypes</tt> element on the eClassifiers
element that has an xsi:type of ecore:EClass in the ecore
document.</td>
<td>All the classes that are listed in the <tt>extends</tt> clause of the <tt>interface</tt> statement.</td>
</tr>
</table>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1077" name="s1077"><b
class="section2">3.04 <tt class="code">EEnum</tt>
Properties</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The properties of an <b class="javaObj"><tt class="code">EEnum</tt></b> in Ecore are:
</p>

<p style="text-align: center"><a id="table5" name="table5"><span
class="jet">TABLE 5. Ecore Properties for <tt class="code">EEnum</tt></span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>Usage</b>
</th>
<th>
<b>Default</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>Used to construct the name of the generated <tt>public final class</tt></td>
<td>no default</td>
</tr>

<tr>
<td><tt>instanceClass</tt></td>
<td>Used by the EMF runtime to validate the type of objects on a
type-safe list. For non-dynamic classes, this is always the
generated enumeration class. null indicates a dynamic class.</td>
<td>the generated enumeration class</td>
</tr>

<tr>
<td><tt>defaultValue</tt></td>
<td>The intrinsic default value for an enumeration. This default
will be applied to any attributes of the enumeration type that do
not specify an explicit default. Note: this property cannot be
modified for <tt class="code">EEnum</tt> objects. It's value
is always the first enumerator.</td>
<td>first enumerator</td>
</tr>

<tr>
<td><tt>serializable</tt></td>
<td>Controls whether or not the generated factory will contain <tt class="code">convertToString()</tt> and <tt class="code">createFromString()</tt> methods for a datatype. Note:
this property cannot be modified for <tt class="code">EEnum</tt> objects. It's value is always <tt>true</tt> .</td>
<td><tt>true</tt></td>
</tr>

<tr>
<td><tt>eLiterals</tt></td>
<td>The literals associated with this enumeration. Used to
construct the <tt>final static</tt> integers and
literals that comprise the generated <tt>class.</tt>
(See <a class="" href="#s1078"><tt class="code">EEnumLiteral</tt> Properties</a>.)</td>
<td>none</td>
</tr>
</table>

<p>
 These properties are specified to EMF<br />
<br />
 code generation in one of the following ways:
</p>
<p>
 

<ul>
<li class="Bulleted">UML - The properties are set via a UML class
object that has a stereotype of <tt>&lt;&lt;enumeration&gt;&gt;</tt> , or via the
specification dialog box for that class. (See See <a
class="" href="#s1041">Attribute Specifications in UML</a>.
for anexample.)</li>

<li class="Bulleted">XMI - The properties are specified as
attributes or sub-elements of an <tt>ecore:EEnumeration</tt> element in the XMI document.
The <tt>ecore:EEnumeration</tt> is typically one of
the <tt>eClassifiers</tt> sub-elements of the <tt>ecore:EPackage</tt> object that is at the root of
the XMI document. (See See The EmploymentType Enumeration Element
in the Ecore Document. for an example.)</li>

<li class="Bulleted">Java - The properties are derived from the <tt>class</tt> statement for an enumeration or from the
<tt>@model</tt> tag that precedes the <tt>class</tt> statement. Note: this <tt>class</tt> statement must be preceded by a <tt class="code">@model</tt> tag and should flagged as <tt>public</tt> and <tt>final</tt> and
should <tt>extend</tt> the <tt class="code">org.eclipse.emf.common.util.AbstractEnumerator</tt>
class. (See See Java Specification for the EmploymentType
Enumeration. for an example.)</li>
</ul>

<br />
 

<p style="text-align: center"><a id="table6" name="table6"><span
class="jet">TABLE 6. Codegen Specification for <tt class="code">EEnum</tt> Properties</span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>UML</b>
</th>
<th>
<b>XMI</b>
</th>
<th>
<b>Java</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>The name of a UML class that has the <tt>&lt;&lt;enumeration&gt;&gt;</tt> stereotype</td>
<td>name attribute<a href="#pgfId=965286"
class="footnote">15</a></td>
<td>The name of enumeration class. (An enumeration class is any
java <tt>class</tt> that is preceded by a <tt class="code">@model</tt> tag.)</td>
</tr>

<tr>
<td><tt>instanceClass</tt></td>
<td>n/a<sup><a href="#fn16" class="footnote">16</a></sup></td>
<td>n/aSee You do not specify the instanceClass property
explicitly. The value is always the generated class.</td>
<td>n/aSee You do not specify the instanceClass property
explicitly. The value is always the generated class.</td>
</tr>

<tr>
<td><tt>defaultValue</tt></td>
<td>n/a<sup><a href="#fn17" class="footnote">17</a></sup></td>
<td>n/aSee You do not specify the default value property
explicitly. The value is always the first entry on the eLiterals
list.</td>
<td>n/aSee You do not specify the default value property
explicitly. The value is always the first entry on the eLiterals
list.</td>
</tr>

<tr>
<td><tt>serializable</tt></td>
<td>n/a<sup><a href="#fn18" class="footnote">18</a></sup></td>
<td>n/aSee You do not specify the serializable property explicitly
for enumerations. The value of the this property is always
true.</td>
<td>n/aSee You do not specify the serializable property explicitly
for enumerations. The value of the this property is always
true.</td>
</tr>

<tr>
<td><tt>eLiterals</tt></td>
<td>All the attributes of the UML class</td>
<td>eLiterals element on an eClassifiers element that has an
xsi:type of ecore:EEnum in the ecore document.</td>
<td>All variables of type <tt>int</tt> that are
preceded by a <tt>@model</tt> tag. <sup><a href="#fn19"
class="footnote">19</a></sup> </td>
</tr>
</table>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1076" name="s1076"><b
class="section2">3.05 <tt class="code">EDataType</tt>
Properties</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The properties of an <b class="javaObj"><tt class="code">EDataType</tt></b> in Ecore are:
</p>

<p style="text-align: center"><a id="table7" name="table7"><span
class="jet">TABLE 7. Ecore Properties for <tt class="code">EDataType</tt></span></a></p>

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>Usage</b>
</th>
<th>
<b>Default</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>Used to construct the name of the <tt>get()</tt>
method in the package that accesses the datatype.</td>
<td>no default</td>
</tr>

<tr>
<td><tt>instanceClass</tt></td>
<td>Used by code generation in constructing the signature of
accessor methods that are generated for attributes that are typed
to this datatype. Also used by the EMF runtime to validate the type
of objects on a type-safe list.</td>
<td>no default</td>
</tr>

<tr>
<td><tt>defaultValue</tt></td>
<td>The intrinsic default value for a datatype. This default will
be applied to any attributes of the datatype that do not specify an
explicit default.</td>
<td>For java primitive types, the appropriate Java default for the
primitive; Otherwise, <tt>null</tt></td>
</tr>

<tr>
<td><tt>serializable</tt></td>
<td>Controls whether or not the generated factory will contain <tt class="code">convertToString()</tt> and <tt class="code">createFromString()</tt> methods for a datatype. Note:
If the serializable flag is <tt>false</tt> for a
datatype, all attributes of that datatype must be transient.</td>
<td><tt>true</tt></td>
</tr>
</table>

<p>
 These properties are specified to EMF<br />
<br />
 code generation in one of the following ways:
</p>
<p>
 

<ul>
<li class="Bulleted">UML - The properties are set via a UML class
object that has a stereotype of <tt>&lt;&lt;datatype&gt;&gt;</tt> , or via the
specification dialog box for that class. (See See <a
class="" href="#s1041">Attribute Specifications in UML</a>.
for anexample.)</li>

<li class="Bulleted">XMI - The properties are specified as
attributes or sub-elements of an <tt>ecore:EDataType</tt> element in the XMI document.
The <tt>ecore:EDataType</tt> is typically one of the
<tt>eClassifiers</tt> sub-elements of the <tt>ecore:EPackage</tt> object that is at the root of
the XMI document. (See See The Date Datatype Element in the Ecore
Document. for an example.)</li>

<li class="Bulleted">Java - Any usage of a type that is not an EMF
type will be implicitly treated as a datatype. For example, if one
of the attributes or methods in your model uses a type that is not
defined in your model (i.e. there is not interface with the @model
tag to define that type) the type will be treated as a datatype.
Alternatively, you can define a datatype explicitly by adding a <tt class="code">get()</tt> method to the package that defines the type.
The return type of this <tt>get()</tt> method must be <b
class="Code">org.eclipse.emf.ecore.<tt class="code">EDataType</tt></b> and the method must be
preceded by a <tt>@model</tt> tag. (See See Java
Specification for the Enterprise Package. for an example.)</li>
</ul>

<br />
 

<p style="text-align: center"><a id="table8" name="table8"><span
class="jet">TABLE 8. Codegen Specifications for <tt class="code">EDataType</tt> Properties</span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>UML</b>
</th>
<th>
<b>XMI</b>
</th>
<th>
<b>Java</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>The name of a UML class that has the <tt>&lt;&lt;datatype&gt;&gt;</tt> stereotype</td>
<td><tt>name</tt> attribute<sup><a href="#fn20"
class="footnote">20</a></sup></td>
<td>The name of <tt>get()</tt> method, without the "<tt class="code">get</tt> " prefix.</td>
</tr>

<tr>
<td><tt>instanceClass</tt></td>
<td>The name of an attribute of the class which has the <tt>&lt;&lt;javaclass&gt;&gt;</tt> stereotype</td>
<td><tt>instanceClass</tt> attributeSee Specified on
an eClassifiers element that has an xsi:type of ecore:EDataType in
the ecore document.</td>
<td>The <tt>instanceClass</tt> property<sup><a
href="#fn21" class="footnote">21</a></sup></td>
</tr>

<tr>
<td><tt>defaultValue</tt></td>
<td>n/a<sup><a href="#fn22" class="footnote">22</a></sup></td>
<td>n/aSee You do not specify the default value property
explicitly. For java primitive types, the value is the appropriate
Java default for the primitive; Otherwise it is null.</td>
<td>n/aSee You do not specify the default value property
explicitly. For java primitive types, the value is the appropriate
Java default for the primitive; Otherwise it is null.</td>
</tr>

<tr>
<td><tt>serializable</tt></td>
<td>The <tt>abstract</tt> property on the UML
class<sup><a href="#fn23" class="footnote">23</a></sup> .</td>
<td><tt>serializable</tt> attribute on an
eClassifiers element that has an xsi:type of ecore:EDataType in the
ecore document.</td>
<td>The <tt>serializable</tt> propertySee This property
is specified via the @model tag that precedes the get() method that
defines the datatype.</td>
</tr>
</table>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1079" name="s1079"><b
class="section2">3.06 <tt class="code">EAttribute</tt>
Properties</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 
</p>
<p>
 The properties of an <b class="javaObj"><tt class="code">EAttribute</tt></b> in Ecore are:
</p>

<p style="text-align: center"><a id="table9" name="table9"><span
class="jet">TABLE 9. Ecore Properties for <tt class="code">EAttribute</tt></span></a></p>

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>Usage</b>
</th>
<th>
<b>Default</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>Name used to construct the names of accessor methods</td>
<td>no default</td>
</tr>

<tr>
<td><tt>eType</tt></td>
<td>The type of the attribute. Note: this must be an
EDatatype.</td>
<td>no default</td>
</tr>

<tr>
<td><tt>changeable</tt></td>
<td>Indicates whether the attribute may be modified. If <tt>changable</tt> is <tt>true</tt> , a <tt class="code">set()</tt> method is generated for the attribute.
Otherwise, no <tt>set()</tt> method is generated.</td>
<td>true</td>
</tr>

<tr>
<td><tt>volatile</tt></td>
<td>Indicates whether the attribute cannot be cached. If <tt>volatile</tt> is <tt>true</tt> , the
generated class does not contain a field to hold the attribute and
the generated <tt>get()</tt> and <tt class="code">set()</tt> methods for the attribute are empty. In this
case you should provide your own implementation of the accessor
methods. Otherwise, the default implementations for these methods
will provide the expected behavior.</td>
<td>false</td>
</tr>

<tr>
<td><tt>transient</tt></td>
<td>Indicates whether the attribute should not be stored. If <tt>transient</tt> is <tt>true</tt> , the
XMI serializer will not write this attribute out when the class is
serialized. Otherwise, the attribute will be serialized.</td>
<td>false</td>
</tr>

<tr>
<td><tt>unique</tt></td>
<td>Indicates whether a many-valued attribute is allowed to have
duplicates. If <tt>unique</tt> is <tt>true</tt> , the implementation of the list that is
used to contain the values will enforce uniqueness.</td>
<td>true</td>
</tr>

<tr>
<td><tt>defaultValue</tt></td>
<td>Determines the value returned by the get method if the
attribute has never been set.</td>
<td>no default</td>
</tr>

<tr>
<td><tt>lowerBound</tt></td>
<td>Determines the setting of the <tt>required</tt>
property (see below). If <tt>lowerBound</tt> is <tt>0</tt> , the <tt>required</tt>
property will be set to <tt>false</tt> . Otherwise,
the <tt>required</tt> property will be <tt>true</tt> .</td>
<td>0</td>
</tr>

<tr>
<td><tt>upperBound</tt></td>
<td>Determines the setting of the <tt>many</tt>
property (see below). If <tt>upperBound</tt> is <tt>1</tt> , the <tt>many</tt> property
will be set to <tt>false</tt> . Otherwise, the <tt>many</tt> property will be <tt>true</tt> .</td>
<td>1</td>
</tr>

<tr>
<td><tt>many</tt></td>
<td>If <tt>many</tt> is <tt>true</tt> ,
there is no <tt>set()</tt> method for the attribute and
the <tt>get()</tt> method returns a list that can only
contain objects of the appropriate type. Otherwise, both <tt class="code">get()</tt> and <tt>set()</tt> methods are
generated and they return and receive a reference to a single
object of the appropriate type.</td>
<td>false</td>
</tr>

<tr>
<td><tt>required</tt></td>
<td>Indicates whether the attribute is required. Note: this
property has no impact on code generation or on the EMF runtime.
This property is has the potential to be useful for
validation.</td>
<td>false</td>
</tr>

<tr>
<td><tt>unsettable</tt></td>
<td>Indicates that the attribute may be unset. If <tt>unsettable</tt> is <tt>true</tt> , an
<tt>isSet()</tt> method is generated for the attribute.
Note that this requires additional runtime storage for the
class</td>
<td>false</td>
</tr>
</table>

<p>
 These properties are specified to EMF<br />
<br />
 code generation in one of the following ways:
</p>
<p>
 

<ul>
<li class="Bulleted">UML - The properties are set by via an
attribute belonging to a UML class object or via the specification
dialog box for that attribute. (See See <a class=""
href="#s1039">Basic UML Model Elements</a>. and See <a
class="" href="#s1042">The eCore Properties Page</a>. for
examples.)</li>

<li class="Bulleted">XMI - The properties are specified as
attributes or sub-elements of an <tt>ecore:EAttribute</tt> element in the XMI document.
The <tt>ecore:EAttribute</tt> is typically one of the
<tt>eAttributes</tt> sub-elements of an <tt>ecore:EClass</tt> object, which in turn is one of
the <tt>eClassifiers</tt> sub-elements of the <tt>ecore:EPackage</tt> object that is at the root of
the XMI document. (See See The Employee Class Element in the Ecore
Document. for examples.)</li>

<li class="Bulleted">Java - The properties are derived from the <tt class="code">get()</tt> method in the <tt>interface</tt> that defines the class to which this
attribute belongs. This <tt>get()</tt> method must be
preceded by a <tt>@model</tt> tag. (See See Java
Specification for the Employee Class. for examples.)</li>
</ul>

<br />
 

<p style="text-align: center"><a id="table10" name="table10"><span
class="jet">TABLE 10. Codegen Specifications for <tt class="code">EAttribute</tt></span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>UML</b>
</th>
<th>
<b>XMI</b>
</th>
<th>
<b>Java</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>the name of the UML attribute</td>
<td><tt>name</tt> attribute<sup><a href="#fn24"
class="footnote">24</a></sup></td>
<td>name of <tt>get()</tt> method, without the "<tt class="code">get</tt> " prefix</td>
</tr>

<tr>
<td><tt>eType</tt></td>
<td>the type of the UML attribute</td>
<td><tt>eType</tt> attribute on an eAttributes
element in the ecore document.</td>
<td>For single-valued attributes, the return type of the get()
method. Otherwise, the eType property is specified via the @model
tag that precedes the get() method that defines the get() method
that defines the attribute.</td>
</tr>

<tr>
<td><tt>changeable</tt></td>
<td><tt>isChangeable</tt> property<sup><a
href="#fn25" class="footnote">25</a></sup></td>
<td><tt>changeable</tt> attribute on an eAttributes
element in the ecore document.</td>
<td><tt>changeable</tt> property is specified via the
@model tag that precedes the get() method that defines the get()
method that defines the attribute.</td>
</tr>

<tr>
<td><tt>volatile</tt></td>
<td><tt>isVolatile</tt> property is specified on the
eCore page of the specification dialog for the UML Attribute.</td>
<td><tt>volatile</tt> attribute on an eAttributes
element in the ecore document.</td>
<td><tt>volatile</tt> property is specified via the
@model tag that precedes the get() method that defines the get()
method that defines the attribute.</td>
</tr>

<tr>
<td><tt>transient</tt></td>
<td><tt>isTransient</tt> property is specified on the
eCore page of the specification dialog for the UML Attribute.</td>
<td><tt>transient</tt> attribute on an eAttributes
element in the ecore document.</td>
<td><tt>transient</tt> property<sup><a href="#fn26"
class="footnote">26</a></sup></td>
</tr>

<tr>
<td><tt>unique</tt></td>
<td><tt>isUnique</tt> property is specified on the
eCore page of the specification dialog for the UML Attribute.</td>
<td><tt>unique</tt> attribute on an eAttributes
element in the ecore document.</td>
<td><tt>unique</tt> property is specified via the @model
tag that precedes the get() method that defines the get() method
that defines the attribute.</td>
</tr>

<tr>
<td><tt>defaultValue</tt></td>
<td>The initial value assigned to the attribute</td>
<td><tt>defaultValue</tt> attribute on an eAttributes
element in the ecore document.</td>
<td><tt>defaultValue</tt> property is specified via the
@model tag that precedes the get() method that defines the get()
method that defines the attribute.</td>
</tr>

<tr>
<td><tt>lowerBound</tt></td>
<td>cardinality stereotype<a href="#pgfId=954579"
class="footnote">27</a></td>
<td><tt>lowerBound</tt> attribute on an eAttributes
element in the ecore document.</td>
<td>The <tt>lowerBound</tt> property is specified via
the @model tag that precedes the get() method that defines the
get() method that defines the attribute.</td>
</tr>

<tr>
<td><tt>upperBound</tt></td>
<td>cardinality stereotypeSee The cardinality stereotype is
specified as &lt;&lt;lowerBound..upperBound&gt;&gt; where
lowerBound is either 0 or 1 and upperBound is either 1 or *. If the
cardinality stereotype is omitted, &lt;&lt;0..1&gt;&gt; is
assumed.</td>
<td><tt>upperBound</tt> attribute on an eAttributes
element in the ecore document.</td>
<td>The <tt>upperBound</tt> property is specified via
the @model tag that precedes the get() method that defines the
get() method that defines the attribute. , if it exists; Otherwise,
the return type of the get method<a href="#pgfId=963464"
class="footnote">28</a></td>
</tr>

<tr>
<td><tt>many</tt></td>
<td>n/a<sup><a href="#fn29" class="footnote">29</a></sup></td>
<td>n/aSee You do not specify the many property explicitly. The
value is derived from the upperBound.</td>
<td>n/aSee You do not specify the many property explicitly. The
value is derived from the upperBound.</td>
</tr>

<tr>
<td><tt>required</tt></td>
<td>n/a<sup><a href="#fn30" class="footnote">30</a></sup></td>
<td>n/aSee You do not specify the required property explicitly. The
value is derived from the lowerBound.</td>
<td>n/aSee You do not specify the required property explicitly. The
value is derived from the lowerBound.</td>
</tr>

<tr>
<td><tt>unsettable</tt></td>
<td>isUnsettable property is specified on the eCore page of the
specification dialog for the UML Attribute.</td>
<td><tt>unsettable</tt> attribute on an eAttributes
element in the ecore document.</td>
<td><tt>unsettable</tt> property is specified via the
@model tag that precedes the get() method that defines the get()
method that defines the attribute.</td>
</tr>
</table>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1080" name="s1080"><b
class="section2">3.07 <tt class="code">EReference</tt>
Properties</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The properties of an <b class="javaObj"><tt class="code">EReference</tt></b> in Ecore are:
</p>

<p style="text-align: center"><a id="table11" name="table11"><span
class="jet">TABLE 11. Ecore Properties for <tt class="code">EReference</tt></span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>Usage</b>
</th>
<th>
<b>Default</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>Name used to construct the names of accessor methods</td>
<td>no default</td>
</tr>

<tr>
<td><tt>eType</tt></td>
<td>The type of the reference. In the case of single-valued
references, the <tt>eType</tt> is the return type of
the generated <tt>get()</tt> method. For multi-valued
references, the <tt>eType</tt> is the type of objects
that are allowed on the type-safe list that is returned by the <tt class="code">get()</tt> method. Note: for references, the eType must
be an <tt class="code">EClass</tt></td>
<td>no default</td>
</tr>

<tr>
<td><tt>changeable</tt></td>
<td>Indicates whether the reference may be modified. If changeable
is false, no <tt>set()</tt> method is generated for the
reference</td>
<td>true</td>
</tr>

<tr>
<td><tt>volatile</tt></td>
<td>Indicates whether the reference cannot be cached. If volatile
is true, the generated class does not contain a field to hold the
reference and the generated <tt>get()</tt> and <tt class="code">set()</tt> methods for the reference are empty. In this
case you should provide your own implementation of the accessor
methods.</td>
<td>false</td>
</tr>

<tr>
<td><tt>transient</tt></td>
<td>Indicates whether the reference should not be stored. If
transient is true, the XMI serializer will not write this reference
out when the class is serialized.</td>
<td>false</td>
</tr>

<tr>
<td><tt>unique</tt></td>
<td>Indicates whether a many-valued attribute is allowed to have
duplicates. If <tt>unique</tt> is <tt>true</tt> , the implementation of the list that is
used to contain the values will enforce uniqueness. Note: The
setting of the <tt>unique</tt> is always <tt>true</tt> for references.</td>
<td>true</td>
</tr>

<tr>
<td><tt>defaultValue</tt></td>
<td>Determines the value returned by the get method if the
attribute has never been set. Note: The <tt>defaultValue</tt> property is always <tt>null</tt> for references. It cannot be
modified.</td>
<td></td>
</tr>

<tr>
<td><tt>lowerBound</tt></td>
<td>Determines the setting of the <tt>required</tt>
property (see below). If <tt>lowerBound</tt> is <tt>0</tt> , the <tt>required</tt>
property will be set to <tt>false</tt> . Otherwise,
the <tt>required</tt> property will be <tt>true</tt> .</td>
<td>0</td>
</tr>

<tr>
<td><tt>upperBound</tt></td>
<td>Determines the setting of the <tt>many</tt>
property (see below). If <tt>upperBound</tt> is <tt>1</tt> , the <tt>many</tt> property
will be set to <tt>false</tt> . Otherwise, the <tt>many</tt> property will be <tt>true</tt> .</td>
<td>1</td>
</tr>

<tr>
<td><tt>many</tt></td>
<td>Indicates whether the reference is single-valued or
multi-valued. If <tt>many</tt> is <tt>true</tt> , there is no <tt>set()</tt>
method for the attribute and the <tt>get()</tt> method
returns a list that can only contain objects of the appropriate
type. Otherwise, both <tt>get()</tt> and <tt class="code">set()</tt> methods are generated and they return and
receive a reference to a single object of the appropriate
type.</td>
<td>false</td>
</tr>

<tr>
<td><tt>required</tt></td>
<td>Indicates whether the reference is required. Note: this
property has no impact on code generation or on the EMF runtime.
This property is has the potential to be useful for
validation.</td>
<td>false</td>
</tr>

<tr>
<td><tt>containment</tt></td>
<td>Indicates whether the reference is a containment. If
containment is true, the generated accessor methods will enforce
containment semantics. (E.g., if you add an object to a new
container, that object will be automatically removed from any
existing container.</td>
<td><tt>false</tt></td>
</tr>

<tr>
<td><tt>container</tt></td>
<td>Indicates whether the reference is a container. This is the
opposite of a containment <tt class="code">EReference</tt>.
If container is true, the generated accessor methods will have
container semantics.</td>
<td><tt>false</tt></td>
</tr>

<tr>
<td><tt>resolveProxies</tt></td>
<td>Indicates whether proxy references should be resolved
automatically.</td>
<td><tt>true</tt></td>
</tr>

<tr>
<td><tt>eOpposite</tt></td>
<td>Identifies the <tt class="code">EReference</tt> that
represents the opposite end of the relationship. This is used by
the EMF runtime to preserve bidirectional referential integrity.
(E.g., if you set one end of a relationship, the opposite end will
be set automatically.)</td>
<td><tt>null</tt></td>
</tr>
</table>


</p>
<p>
 These properties are specified to EMF<br />
<br />
 code generation in one of the following ways:
</p>
<p>
 

<ul>
<li class="Bulleted">UML - The properties are set by via a one of
the roles of a relation belonging to a UML class object or via the
specification dialog box for that role. (See See Basic UML Model
Elements. and See The eCore Properties Page. for examples.)</li>

<li class="Bulleted">XMI - The properties are specified as
attributes or sub-elements of an <tt>ecore:EReference</tt> element in the XMI document.
The <tt>ecore:EReference</tt> is typically one of the
<tt>eReferences</tt> sub-elements of an <tt>ecore:EClass</tt> object, which in turn is one of
the <tt>eClassifiers</tt> sub-elements of the <tt>ecore:EPackage</tt> object that is at the root of
the XMI document. (See See The Company Class Element in the Ecore
Document. for examples.)</li>

<li class="Bulleted">Java - The properties are derived from the <tt class="code">get()</tt> method in the <tt>interface</tt> that defines the class to which this
attribute belongs. The method must be preceded by a <tt class="code">@model</tt> tag. (See See Java Specification for the
Company Class. for examples.)</li>
</ul>

<br />
 

<p style="text-align: center"><a id="table12" name="table12"><span
class="jet">TABLE 12. Codegen Specifications for <tt class="code">EReference</tt> Properties</span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>UML</b>
</th>
<th>
<b>XMI</b>
</th>
<th>
<b>Java</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>The name of the UML relation.</td>
<td><tt>name</tt> attribute<sup><a href="#fn31"
class="footnote">31</a></sup></td>
<td>The name of <tt>get()</tt> method, without the "<tt class="code">get</tt> " prefix.</td>
</tr>

<tr>
<td><tt>eType</tt></td>
<td>The type of the UML relation.</td>
<td><tt>eType</tt> attribute on an eReferences
element in the ecore document.</td>
<td>For single-valued attributes, the return type of the get()
method. Otherwise, the eType property is specified via the @model
tag that precedes the get() method that defines the get() method
that defines the reference.</td>
</tr>

<tr>
<td><tt>changeable</tt></td>
<td><tt>isChangeable</tt> property<sup><a
href="#fn32" class="footnote">32</a></sup></td>
<td><tt>changeable</tt> attribute on an eReferences
element in the ecore document.</td>
<td>The <tt>changeable</tt> property is specified via
the @model tag that precedes the get() method that defines the
get() method that defines the attribute.</td>
</tr>

<tr>
<td><tt>volatile</tt></td>
<td><tt>isVolatile</tt> property is specified on
either the eCoreA or the eCoreB page of the specification dialog
for the UML Association.</td>
<td><tt>volatile</tt> attribute on an eReferences
element in the ecore document.</td>
<td>The <tt>volatile</tt> property is specified via the
@model tag that precedes the get() method that defines the get()
method that defines the reference.</td>
</tr>

<tr>
<td><tt>transient</tt></td>
<td><tt>isTransient</tt> property is specified on
either the eCoreA or the eCoreB page of the specification dialog
for the UML Association.</td>
<td><tt>transient</tt> attribute on an eReferences
element in the ecore document.</td>
<td>The <tt>transient</tt> property<sup><a href="#fn33"
class="footnote">33</a></sup></td>
</tr>

<tr>
<td><tt>unique</tt></td>
<td><tt>isUnique</tt> property is specified on either
the eCoreA or the eCoreB page of the specification dialog for the
UML Association.</td>
<td><tt>unique</tt> attribute on an eReferences
element in the ecore document.</td>
<td>The <tt>unique</tt> property is specified via the
@model tag that precedes the get() method that defines the get()
method that defines the reference.</td>
</tr>

<tr>
<td><tt>defaultValue</tt></td>
<td>The initial value assigned to the attribute</td>
<td><tt>defaultValue</tt> attribute on an eReferences
element in the ecore document.</td>
<td>The defaultValue property is specified via the @model tag that
precedes the get() method that defines the get() method that
defines the reference.</td>
</tr>

<tr>
<td><tt>lowerBound</tt></td>
<td>cardinality<a href="#pgfId=954889" class="footnote">34</a></td>
<td><tt>lowerBound</tt> attribute on an eReferences
element in the ecore document.</td>
<td>The <tt>lowerBound</tt> property is specified via
the @model tag that precedes the get() method that defines the
get() method that defines the attribute.</td>
</tr>

<tr>
<td><tt>upperBound</tt></td>
<td>cardinalitySee The cardinality is specified as
lowerBound..upperBound where lowerBound is either 0 or 1 and
upperBound is either 1 or *. If the cardinality is omitted, 0..* is
assumed.</td>
<td><tt>upperBound</tt> attribute on an eReferences
element in the ecore document.</td>
<td>The <tt>upperBound</tt> property is specified via
the @model tag that precedes the get() method that defines the
get() method that defines the attribute. , if it exists; Otherwise,
the return type of the get method<a href="#pgfId=963642"
class="footnote">35</a></td>
</tr>

<tr>
<td><tt>many</tt></td>
<td>n/a<sup><a href="#fn36" class="footnote">36</a></sup></td>
<td>n/aSee You do not specify the many property explicitly. The
value is derived from the upperBound.</td>
<td>n/aSee You do not specify the many property explicitly. The
value is derived from the upperBound.</td>
</tr>

<tr>
<td><tt>required</tt></td>
<td>n/a<sup><a href="#fn37" class="footnote">37</a></sup></td>
<td>n/aSee You do not specify the required property explicitly. The
value is derived from the lowerBound.</td>
<td>n/aSee You do not specify the required property explicitly. The
value is derived from the lowerBound.</td>
</tr>

<tr>
<td><tt>containment</tt></td>
<td>roles that are marked as aggregates and have by-value
containment</td>
<td><tt>containment</tt> attribute on an eReferences
element in the ecore document.</td>
<td>The <tt>containment</tt> property is specified via
the @model tag that precedes the get() method that defines the
get() method that defines the attribute.</td>
</tr>

<tr>
<td><tt>container</tt></td>
<td>the class on the owning side of a containment relation</td>
<td><tt>container</tt> attribute on an eReferences
element in the ecore document.</td>
<td>The <tt>container</tt> property is specified via the
@model tag that precedes the get() method that defines the get()
method that defines the attribute.</td>
</tr>

<tr>
<td><tt>resolveProxies</tt></td>
<td><tt>resolveProxies</tt> propertySee This property
is specified on either the eCoreA or the eCoreB page of the
specification dialog for the UML Association.</td>
<td><tt>resolveProxies</tt> attribute on an
eReferences element in the ecore document.</td>
<td>The <tt>resolveProxies</tt> propertySee This
property is specified via the @model tag that precedes the get()
method that defines the get() method that defines the
attribute.</td>
</tr>

<tr>
<td><tt>eOpposite</tt></td>
<td>the relation that represents the opposite role, if it
exists</td>
<td><tt>eOpposite</tt> attribute on an eReferences
element in the ecore document.</td>
<td>The <tt>eOpposite</tt> property is specified via the
@model tag that precedes the get() method that defines the get()
method that defines the attribute.</td>
</tr>
</table>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1078" name="s1078"><b
class="section2">3.08 <tt class="code">EEnumLiteral</tt>
Properties</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The properties of an <b class="javaObj"><tt class="code">EEnumLiteral</tt></b> in Ecore are:
</p>

<p style="text-align: center"><a id="table13" name="table13"><span
class="jet">TABLE 13. Ecore Properties for <tt class="code">EEnumLiteral</tt></span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>Usage</b>
</th>
<th>
<b>Default</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>The name is used to generate the final static constants in the
enumeration class that are used to access the literal. These names
are derived by inserting "_" characters to separate the words in
the name and converting the name to upper case. One of the final
static constants is the result of this conversion and the other one
has the suffix of "_LITERAL"</td>
<td>no default</td>
</tr>

<tr>
<td><tt>value</tt></td>
<td>Determines the integer value that is associated with this
literal</td>
<td>0</td>
</tr>

<tr>
<td><tt>instance</tt></td>
<td>Identifies the instance of the Enumerator that defines the
value of this enumeration literal. This instance may be assigned to
any attributes whose type is the enumeration to which this
enumeration literal belongs.</td>
<td>For dynamic "this"; otherwise the instance of the generated
Enumerator</td>
</tr>
</table>

<p>
 These properties are specified to EMF<br />
<br />
 code generation in one of the following ways:
</p>
<p>
 

<ul>
<li class="Bulleted">UML - The properties are set by via an
attribute belonging to a UML class object that has the <tt>&lt;&lt;enumeration&gt;&gt;</tt> stereotype, or via
the specification dialog box for that attribute. (See See <a
class="" href="#s1041">Attribute Specifications in UML</a>.
for anexample.)</li>

<li class="Bulleted">XMI - The properties are specified as
attributes or sub-elements of an <tt>ecore:EEnumLiteral</tt> element in the XMI document.
The <tt>ecore:EEnumLiteral</tt> is typically one of
the <tt>eLiterals</tt> sub-elements of an <tt>ecore:EEnum</tt> object, which in turn is one of the
<tt>eClassifiers</tt> sub-elements of the <tt>ecore:EPackage</tt> object that is at the root of
the XMI document. (See See The EmploymentType Enumeration Element
in the Ecore Document. for an example.)</li>

<li class="Bulleted">Java - The properties are derived from the <tt>public static final int</tt> field that defines the
enumeration literal within the <tt>class</tt> that
defines the enumeration to which this literal belongs. The type of
this field must be <tt>int</tt> and the method must
be preceded by a <tt>@model</tt> tag. (See See Java
Specification for the EmploymentType Enumeration. for an
example.)</li>
</ul>

<br />
 

<p style="text-align: center"><a id="table14" name="table14"><span
class="jet">TABLE 14. Codegen Specifications for <tt class="code">EEnumLiteral</tt> Properties</span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>UML</b>
</th>
<th>
<b>XMI</b>
</th>
<th>
<b>Java</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>The name of the attribute that represents the literal</td>
<td><tt>name</tt> attribute<sup><a href="#fn38"
class="footnote">38</a></sup></td>
<td>The <tt>name</tt> property<sup><a href="#fn39"
class="footnote">39</a></sup> , if it is present, otherwise, the
name of the field.</td>
</tr>

<tr>
<td><tt>value</tt></td>
<td>If specified, the initial value of the attribute. Otherwise,
the literals are numbered consecutively, starting at 0.</td>
<td><tt>value</tt> attribute on an eLiterals element
in the ecore document.</td>
<td>The initial value of the field.</td>
</tr>

<tr>
<td><tt>instance</tt></td>
<td>n/a<sup><a href="#fn40" class="footnote">40</a></sup></td>
<td>n/aSee You do not set the instance property explicitly. This
property is automatically filled in when the package to which the
Enumeration belongs is initialized.</td>
<td>n/aSee You do not set the instance property explicitly. This
property is automatically filled in when the package to which the
Enumeration belongs is initialized.</td>
</tr>
</table>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1081" name="s1081"><b
class="section2">3.09 <tt class="code">EOperation</tt>
Properties</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The properties of an <b class="javaObj"><tt class="code">EOperation</tt></b> in Ecore are:
</p>

<p style="text-align: center"><a id="table15" name="table15"><span
class="jet">TABLE 15. Ecore Properties for <tt class="code">EOperation</tt></span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>Usage</b>
</th>
<th>
<b>Default</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>The name of the generated method.</td>
<td>no default</td>
</tr>

<tr>
<td><tt>eType</tt></td>
<td>The return type of the me.thod</td>
<td>null</td>
</tr>

<tr>
<td><tt>eParameters</tt></td>
<td>The signature of the method. (See <a class=""
href="#s1082"><tt class="code">EParameter</tt>
Properties</a>.)</td>
<td>none</td>
</tr>
</table>

<p>
 These properties are specified to EMF<br />
<br />
 code generation in one of the following ways:
</p>
<p>
 

<ul>
<li class="Bulleted">UML - The properties are set by via an
operation belonging to a UML class object, or via the specification
dialog box for that operation. (See See Attribute Specifications in
UML. for an example.)</li>

<li class="Bulleted">XMI - The properties are specified as
attributes or sub-elements of an <tt>ecore:EOperation</tt> element in the XMI document.
The <tt>ecore:EOperation</tt> is typically one of the
<tt>eOperations</tt> sub-elements of an <tt>ecore:EClass</tt> object, which in turn is one of
the <tt>eClassifiers</tt> sub-elements of the <tt>ecore:EPackage</tt> object that is at the root of
the XMI document. (See See The Employee Class Element in the Ecore
Document. for an example.)</li>

<li class="Bulleted">Java - The properties are derived from a
method that is specified within the <tt>interface</tt> that defines the class to which this
operation belongs. The method must be preceded by a <tt class="code">@model</tt> tag. (See See Java Specification for the
Employee Class. for an example.) Note: if there is ambiguity with
an accessor method (i.e. if the name of the method begins with the
prefix "<tt>get</tt> "), the <tt class="code">parameters</tt> property must be specified on the <tt class="code">@model</tt> tag to identify an <tt class="code">EOperation</tt>.</li>
</ul>

<br />
 

<p style="text-align: center"><a id="table16" name="table16"><span
class="jet">TABLE 16. Codegen Specifications for <tt class="code">EOperation</tt> Properties</span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>UML</b>
</th>
<th>
<b>XM</b>
</th>
<th>
<b>Java</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td></td>
<td><tt>name</tt> attribute<sup><a href="#fn41"
class="footnote">41</a></sup></td>
<td></td>
</tr>

<tr>
<td><tt>eType</tt></td>
<td></td>
<td><tt>eType</tt> attribute on an eOperations
element in the ecore document.</td>
<td></td>
</tr>

<tr>
<td><tt>eParameters</tt></td>
<td></td>
<td><tt>eParameters</tt> element on an eOperations
element in the ecore document.</td>
<td></td>
</tr>
</table>


</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1082" name="s1082"><b
class="section2">3.10 <tt class="code">EParameter</tt>
Properties</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The properties of an <b class="javaObj"><tt class="code">EParameter</tt></b> in Ecore are:
</p>

<p style="text-align: center"><a id="table17" name="table17"><span
class="jet">TABLE 17. Ecore Properties for <tt class="code">EParameter</tt></span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>Usage</b>
</th>
<th>
<b>Default</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>The name of the generated argument</td>
<td>no default</td>
</tr>

<tr>
<td><tt>eType</tt></td>
<td>The type of the argument</td>
<td>no default</td>
</tr>
</table>

<p>
 These properties are specified to EMF<br />
<br />
 code generation in one of the following ways:
</p>
<p>
 

<ul>
<li class="Bulleted">UML - The properties are set by via an
argument on an operation belonging to a UML class object, or via
the specification dialog box for that argument. (See See Attribute
Specifications in UML. for an example.)</li>

<li class="Bulleted">XMI - The properties are specified as
attributes of an <tt>ecore:EParameter</tt> element in
the XMI document. The <tt>ecore:EParameter</tt> is
typically one of the <tt>eParameter</tt> s
sub-elements of an <tt>ecore:EOperation</tt> object,
which in turn is one of the <tt>eOperations</tt>
sub-elements of an <tt>ecore:EClass</tt> object,
which in turn is one of the <tt>eClassifiers</tt>
sub-elements of the <tt>ecore:EPackage</tt> object
that is at the root of the XMI document. (See See The Employee
Class Element in the Ecore Document. for an example.)</li>

<li class="Bulleted">Java - The properties are derived from the
signature of the method to which this parameter belongs. The method
must be preceded by a <tt>@model</tt> tag. (See See Java
Specification for the Employee Class. for an example.)</li>
</ul>

<br />
 

<p style="text-align: center"><a id="table18" name="table18"><span
class="jet">TABLE 18. Codegen Specifications for <tt class="code">EParameter</tt> Properties</span></a></p>

<br />
<br />
 

<table cellspacing="2" cellpadding="2" border="1">
<tr>
<th>
<b>Property</b>
</th>
<th>
<b>UML</b>
</th>
<th>
<b>XMI</b>
</th>
<th>
<b>Java</b>
</th>
</tr>

<tr>
<td><tt>name</tt></td>
<td>the name of the argument that represents this parameter</td>
<td><tt>name</tt> attribute<sup><a href="#fn42"
class="footnote">42</a></sup></td>
<td>the name of the argument that represents the parameter</td>
</tr>

<tr>
<td><tt>eType</tt></td>
<td>the type of the argument</td>
<td><tt>eType</tt> attribute on an eParameters
element in the ecore document.</td>
<td>the type of the argument</td>
</tr>
</table>

<br />
<br />
 <!-- tables end  -->
<br />
<br />
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1073" name="s1073"><h2>3.11 EMF APIs</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 The APIs for the EMF runtime are described in detail in the
JavaDoc document for EMF. You can access this document through the
"Documents" section of the EMF web site. Please see <a
class="" target="new"
href="http://www.eclipse.org/emf/">http://www.eclipse.org/emf/</a>
for details.
</p>
<p>
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s" name="s"><b class="section1">4
Appendices</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>
<p>
 

<ul>
<li>See <a class="" href="#s1084">Appendix A - The Ecore
Model</a>.</li>
<li>See <a class="" href="#s1085">Appendix B -
Footnotes</a>.</li></ul>

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1084" name="s1084"><h2>4.01 Appendix A - The Ecore Model</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


</p>

<p style="text-align: center"><a id="fig11" name="fig11"><span
class="jet"><img src="images/EMFUG-11.jpg" width="418"
height="322" border="0"
alt="FIGURE 11. Ecore Model Class Hierarchy" /><br />
FIGURE 11. Ecore Model Class Hierarchy</span></a></p>

<p style="text-align: center"><a id="fig12" name="fig12"><span
class="jet"><img src="images/EMFUG-12.jpg" width="432"
height="355" border="0"
alt="FIGURE 12. Ecore Model Relationships, Attributes, and Operations" /><br />
 FIGURE 12. Ecore Model Relationships, Attributes, and
Operations</span></a></p>

<br />
<br />
 

<table cellspacing="0" cellpadding="0" border="0"
width="100%">
<tr valign="top">
<td nowrap="nowrap"><a id="s1085" name="s1085"><h2>4.02 Appendix B - Footnotes</h2></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>
</table>


<p>
 <a id="fn1" name="fn1">1</a>. For a single-valued attribute of
type boolean, an is() method is generated instead of a get()
method.
</p>
<p>
 <a id="fn2" name="fn2">2</a>. Specified on the ecore:Package
element in the ecore document
</p>
<p>
 <a id="fn3" name="fn3">3</a>. This is the Java package that is
specified on the package statement of the interfaces and/or classes
contained in the package.
</p>
<p>
 <a id="fn4" name="fn4">4</a>. This property is specified on the
eCore page of the specification dialog for the UML Package.
</p>
<p>
 <a id="fn5" name="fn5">5</a>. This field is a member of the
interface that corresponds to the package itself.
</p>
<p>
 <a id="fn6" name="fn6">6</a>. Subpackages cannot be specified if
you use Java interfaces to specify your model.
</p>
<p>
 <a id="fn7" name="fn7">7</a>. Specified on the subPackages element
in the genmodel document.
</p>
<p>
 <a id="fn8" name="fn8">8</a>. Depending on the properties of the
attribute or reference, the accessor methods may be get(), set(),
isSet() and unset(). Usually, the implementations of these methods
are generated automatically.
</p>
<p>
 <a id="fn9" name="fn9">9</a>. Specified on the <tt class="code">EClassifiers</tt> element that has an xsi:type of
ecore:<tt class="code">EClass</tt> in the ecore
document
</p>
<p>
 <a id="fn10" name="fn10">10</a>. You do not specify the
instanceClass property explicitly. The value is always the
generated interface.
</p>
<p>
 <a id="fn11" name="fn11">11</a>. You do not specify the default
value property explicitly. The value is always null.
</p>
<p>
 <a id="fn12" name="fn12">12</a>. This property is set in Rational
Rose using the "Abstract" checkbox on the "Details" page of the
"Specification" dialog for a class.
</p>
<p>
 <a id="fn13" name="fn13">13</a>. The property is specified via the
@model tag that precedes the interface statement for the
class.
</p>
<p>
 <a id="fn14" name="fn14">14</a>. If there is potential ambiguity
with a get() method, you need to specify the "parameters=" attribute to give signature of the method.
</p>
<p>
 <a id="fn15" name="fn15">15</a>. Specified on an <tt class="code">EClassifiers</tt> element that has an xsi:type of
ecore:EEnum in the ecore document
</p>
<p>
 <a id="fn16" name="fn16">16</a>. You do not specify the
instanceClass property explicitly. The value is always the
generated class.
</p>
<p>
 <a id="fn17" name="fn17">17</a>. You do not specify the default
value property explicitly. The value is always the first entry on
the eLiterals list.
</p>
<p>
 <a id="fn18" name="fn18">18</a>. You do not specify the
serializable property explicitly for enumerations. The value of the
this property is always true.
</p>
<p>
 <a id="fn19" name="fn19">19</a>. The @model tag may have a name=
argument, but should not have any other arguments.
</p>
<p>
 <a id="fn20" name="fn20">20</a>. Specified on an <tt class="code">EClassifiers</tt> element that has an xsi:type of
ecore:EDataType in the ecore document
</p>
<p>
 <a id="fn21" name="fn21">21</a>. This property is specified via
the @model tag that precedes the get() method that defines the
datatype.
</p>
<p>
 <a id="fn22" name="fn22">22</a>. You do not specify the default
value property explicitly. For java primitive types, the value is
the appropriate Java default for the primitive; Otherwise it is
null.
</p>
<p>
 <a id="fn23" name="fn23">23</a>. This property is set in Rational
Rose using the "Abstract" checkbox on the "Details" page of the
"Specification" dialog for a class.
</p>
<p>
 <a id="fn24" name="fn24">24</a>. Specified on an eAttributes
element in the ecore document
</p>
<p>
 <a id="fn25" name="fn25">25</a>. This property is specified on the
eCore page of the specification dialog for the UML Attribute
</p>
<p>
 <a id="fn26" name="fn26">26</a>. This property is specified via
the @model tag that precedes the get() method that defines the
get() method that defines the attribute.
</p>
<p>
 <a id="fn27" name="fn27">27</a>. The cardinality stereotype is
specified as &lt;&lt;lowerBound..upperBound&gt;&gt; where
lowerBound is either 0 or 1 and upperBound is either 1 or *. If the
cardinality stereotype is omitted, &lt;&lt;0..1&gt;&gt; is
assumed.
</p>
<p>
 <a id="fn28" name="fn28">28</a>. A return type of java.util.List
or org.eclipse.emf.common.util.EList indicates an upperBound of
"-1" (which means there is no upper bound.) Any other type
indicates an upperBound of "1".
</p>
<p>
 <a id="fn29" name="fn29">29</a>. You do not specify the many
property explicitly. The value is derived from the
upperBound.
</p>
<p>
 <a id="fn30" name="fn30">30</a>. You do not specify the required
property explicitly. The value is derived from the
lowerBound.
</p>
<p>
 <a id="fn31" name="fn31">31</a>. Specified on an eReferences
element in the ecore document
</p>
<p>
 <a id="fn32" name="fn32">32</a>. This property is specified on
either the eCoreA or the eCoreB page of the specification dialog
for the UML Association
</p>
<p>
 <a id="fn33" name="fn33">33</a>. This property is specified via
the @model tag that precedes the get() method that defines the
get() method that defines the reference.
</p>
<p>
 <a id="fn34" name="fn34">34</a>. The cardinality is specified as
lowerBound..upperBound where lowerBound is either 0 or 1 and
upperBound is either 1 or *. If the cardinality is omitted, 0..* is
assumed.
</p>
<p>
 <a id="fn35" name="fn35">35</a>. A return type of java.util.List
or org.eclipse.emf.common.util.EList indicates an upperBound of
"-1" (which means there is no upper bound.) Any other type
indicates an upperBound of "1".
</p>
<p>
 <a id="fn36" name="fn36">36</a>. You do not specify the many
property explicitly. The value is derived from the
upperBound.
</p>
<p>
 <a id="fn37" name="fn37">37</a>. You do not specify the required
property explicitly. The value is derived from the
lowerBound.
</p>
<p>
 <a id="fn38" name="fn38">38</a>. Specified on an eLiterals element
in the ecore document
</p>
<p>
 <a id="fn39" name="fn39">39</a>. This property is specified via
the @model tag that precedes the field that defines the
datatype.
</p>
<p>
 <a id="fn40" name="fn40">40</a>. You do not set the instance
property explicitly. This property is automatically filled in when
the package to which the Enumeration belongs is initialized.
</p>
<p>
 <a id="fn41" name="fn41">41</a>. Specified on an eOperations
element in the ecore document
</p>
<p>
 <a id="fn42" name="fn42">42</a>. Specified on an eParameters
element in the ecore document
</p>

 <a id="toc" name="toc">&nbsp;</a> 

<hr noshade="noshade" size="1" />
<table border="0" width="100%">
<tr>
<td colspan="4"><a href="#s"><b>Table Of Contents</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td colspan="3">0 <a href="#s">Overview</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td colspan="3">1 <a href="#s1000">Concepts</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">1.01 <a href="#s1003">Modeling</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">1.02 <a href="#s">The Ecore Model</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">1.03 <a href="#s1004">Code Generation</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">1.04 <a href="#s1009">Basic Code
Generation</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">1.05 <a href="#s1005">Serialization and
Loading</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">1.06 <a href="#s1011"><tt class="code">ResourceSet</tt></a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">1.07 <a href="#s1014"><tt class="code">URIConverter</tt></a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">1.08 <a href="#s1006">XMI</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">1.09 <a href="#s1012"><tt class="code">XMIResource</tt></a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">1.10 <a href="#s1007">Observers and
Notifiers</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td colspan="3">2 <a href="#s1001">Tasks</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.01 <a href="#s1015">Defining Your Model</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.02 <a href="#s1016">Code Generation Using
Rational Rose</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.03 <a href="#s1039">Basic UML Model
Elements</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.04 <a href="#s1040">Specification of Abstract
Classes</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.05 <a href="#s1041">Attribute Specifications in
UML</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.06 <a href="#s1042">The eCore Properties
Page</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.07 <a href="#s1043">Ecore Properties for
Attributes</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.08 <a href="#s1044">Ecore Properties for
Relationships</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.09 <a href="#s1045">Ecore Properties for
Packages</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.10 <a href="#s1046">Specifying Multiple
Inheritance in UML</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.11 <a href="#s1017">Code Generation Using XMI
documents</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.12 <a href="#s1048">Genmodel Document for the
enterprise Model</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.13 <a href="#s1049">The Enterprise Package
Element in the Ecore Document</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.14 <a href="#s1050">The Company Class Element in
the Ecore Document</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.15 <a href="#s1051">The Department Class Element
in the Ecore Document</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.16 <a href="#s1052">The Person Class Element in
the Ecore Document</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.17 <a href="#s1053">The Employee Class Element in
the Ecore Document</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.18 <a href="#s1054">The EmploymentType
Enumeration Element in the Ecore Document</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.19 <a href="#s1055">The Date Datatype Element in
the Ecore Document</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.20 <a href="#s1018">Code Generation Using
Annotated Java Interfaces</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.21 <a href="#s1057">Java Specification for the
Enterprise Package</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.22 <a href="#s1058">Java Specification for the
Company Class</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.23 <a href="#s1059">Java Specification for the
Department Class</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.24 <a href="#s1060">Java Specification for the
Person Class</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.25 <a href="#s1061">Java Specification for the
Employee Class</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.26 <a href="#s1062">Java Specification for the
EmploymentType Enumeration</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.27 <a href="#s1019">Generating your
model</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.28 <a href="#s1021">Registering/Initializing a
Package</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.29 <a href="#s1065">Registering and Initializing
a Generated Package in a Plugin</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.30 <a href="#s1066">Registering and Initializing
a Generated Package Using APIs</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.31 <a href="#s1067">Registering a Dynamic
Package</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.32 <a href="#s1025">Accessing the Package and
Factory classes</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.33 <a href="#s1024">Creating a <tt class="code">Resource</tt></a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.34 <a href="#s1023">Creating a <tt class="code">ResourceSet</tt></a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.35 <a href="#s1022">Registering a <tt class="code">Resource.Factory</tt></a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.36 <a href="#s">Registering a <tt class="code">Resource.Factory</tt> for a Plugin</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.37 <a href="#s">Registering a <tt class="code">Resource.Factory</tt> Globally</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.38 <a href="#s1063">Registering a <tt class="code">URIConverter</tt></a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.39 <a href="#s1064">Registering an <tt class="code">AdapterFactory</tt></a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.40 <a href="#s1026">Running your
application</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.41 <a href="#s1027">Creating Instance
Data</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.42 <a href="#s1029">Loading Instance
Data</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.43 <a href="#s1030">Handling
notifications</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.44 <a href="#s1033">Using Reflective
APIs</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.45 <a href="#s1034">Examining <tt class="code">EObject</tt> Instances using Reflection</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.46 <a href="#s">print</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.47 <a href="#s1069">printObject</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.48 <a href="#s1070">printAllAttributes</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.49 <a href="#s1071">printAttribute</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.50 <a href="#s1068">printAllReferences</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.51 <a href="#s1072">printReference</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">2.52 <a href="#s">Customizing a <tt class="code">URIConverter</tt></a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td colspan="3">3 <a href="#s1002">Quick Reference</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.01 <a href="#s1056">Ecore Properties and Codegen
Specifications</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.02 <a href="#s1074"><tt class="code">EPackage</tt> Properties</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.03 <a href="#s1075"><tt class="code">EClass</tt> Properties</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.04 <a href="#s1077"><tt class="code">EEnum</tt> Properties</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.05 <a href="#s1076"><tt class="code">EDataType</tt> Properties</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.06 <a href="#s1079"><tt class="code">EAttribute</tt> Properties</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.07 <a href="#s1080"><tt class="code">EReference</tt> Properties</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.08 <a href="#s1078"><tt class="code">EEnumLiteral</tt> Properties</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.09 <a href="#s1081"><tt class="code">EOperation</tt> Properties</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.10 <a href="#s1082"><tt class="code">EParameter</tt> Properties</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">3.11 <a href="#s1073">EMF APIs</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td colspan="3">4 <a href="#s">Appendices</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">4.01 <a href="#s1084">Appendix A - The Ecore
Model</a></td>
</tr>

<tr>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td colspan="2">4.02 <a href="#s1085">Appendix B -
Footnotes</a></td>
</tr>
</table>

<a id="tof" name="tof">&nbsp;</a> 

<hr noshade="noshade" size="1" />
<table border="0" width="100%">
<tr>
<td colspan="1"><a href="#fig1"><b>Table Of Figures</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig1">FIGURE 1. UML for enterprise
model</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig2">FIGURE 2. Basic Ecore elements in
UML diagram</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig3">FIGURE 3. Specification Dialog
for the Person Class</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig4">FIGURE 4. Enumerations,
DataTypes, and Default Values</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig5">FIGURE 5. Adding a Properties
File to Your Model</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig6">FIGURE 6. Selecting the eCore.pty
file</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig7">FIGURE 7. Properties page for the
yearsOfService attribute</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig8">FIGURE 8. Properties page for the
employeeOfTheMonth association</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig9">FIGURE 9. Ecore Properties Page
for the Package</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig10">FIGURE 10. UML for Multiple
Inheritance</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig11">FIGURE 11. Ecore Model Class
Hierarchy</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#fig12">FIGURE 12. Ecore Model
Relationships, Attributes, and Operations</a></td>
</tr>
</table>

<a id="tot" name="tot">&nbsp;</a> 

<hr noshade="noshade" size="1" />
<table border="0" width="100%">
<tr>
<td colspan="1"><a href="#table1"><b>Table Of Tables</b></a></td>
<td align="right"><a class=""
href="#top">top</a>&nbsp;|&nbsp;<a class=""
href="#toc">toc</a>&nbsp;|&nbsp;<a class=""
href="#tof">tof</a>&nbsp;|&nbsp;<a class=""
href="#tot">tot</a></td>
</tr>

<tr>
<td colspan="1">* <a href="#table1">TABLE 1. Ecore Properties for
<tt class="code">EPackage</tt></a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table2">TABLE 2. Codegen Specifications
for <tt class="code">EPackage</tt> Properties</a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table3">TABLE 3. Ecore Properties for
<tt class="code">EClass</tt></a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table4">TABLE 4. Codegen Specifications
for <tt class="code">EClass</tt> Properties</a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table5">TABLE 5. Ecore Properties for
<tt class="code">EEnum</tt></a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table6">TABLE 6. Codegen Specification
for <tt class="code">EEnum</tt> Properties</a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table7">TABLE 7. Ecore Properties for
<tt class="code">EDataType</tt></a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table8">TABLE 8. Codegen Specifications
for <tt class="code">EDataType</tt> Properties</a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table9">TABLE 9. Ecore Properties for
<tt class="code">EAttribute</tt></a></td>
</tr>

<tr>
<td colspan="1">* <a href="#table10">TABLE 10. Codegen
Specifications for <tt class="code">EAttribute</tt></a>
</td>
</tr>

<tr>
<td colspan="1">* <a href="#table11">TABLE 11. Ecore Properties for
<tt class="code">EReference</tt></a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table12">TABLE 12. Codegen
Specifications for <tt class="code">EReference</tt>
Properties</a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table13">TABLE 13. Ecore Properties for
<tt class="code">EEnumLiteral</tt></a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table14">TABLE 14. Codegen
Specifications for <tt class="code">EEnumLiteral</tt>
Properties</a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table15">TABLE 15. Ecore Properties for
<tt class="code">EOperation</tt></a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table16">TABLE 16. Codegen
Specifications for <tt class="code">EOperation</tt>
Properties</a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table17">TABLE 17. Ecore Properties for
<tt class="code">EParameter</tt></a> </td>
</tr>

<tr>
<td colspan="1">* <a href="#table18">TABLE 18. Codegen
Specifications for <tt class="code">EParameter</tt>
Properties</a> </td>
</tr>
</table>
<br/>
</body>
</html>

